# 数据结构复习

[TOC]

## 第一章 概述

- **==数据==：所有能输入到计算机中去的==描述客观事物的符号==**
- **==数据元素==：数据的基本单位也称==结点或记录==**
- **==数据项==：有独立含义的数据==最小单位==，也称为域**

- **数据  >  数据元素   >  数据项**

### 数据结构

![image-20220105183707687](https://i0.hdslb.com/bfs/album/1bf4994f4c77555877756508040da389f1de356f.png)

![image-20220105184704870](https://i0.hdslb.com/bfs/album/4d033f2cda64ee17ff5e571b882dcdac73432409.png)

### 算法

**算法的特性**

- **有输入**
- **有输出**
- **有穷性**
- **有效性**
- **确定性**

**算法性能分析**

- **正确性**
- **可读性**
- **健壮性**
- **高效性**
  - **时间复杂度**
  - **空间复杂度**

**算法的特性**

- **有输入**
- **有输出**
- **有穷性**
- **有效性**
- **确定性**

**算法性能分析**

- **正确性**
- **可读性**
- **健壮性**
- **高效性**
  - **时间复杂度**
  - **空间复杂度**

## 第二章 线性表

### 顺序表

**优点：可以方便的随机存取表中的任意结点，存取速度快**

**性能分析**

- **搜索**

![image-20220105184922148](https://i0.hdslb.com/bfs/album/0c20b1a9823c15ac82669540a57362f5e4c9413c.png)

- **插入**

![image-20220105184933796](https://i0.hdslb.com/bfs/album/56b590f479830fb5ccbccf078e548b3b5b070525.png)

- **删除**

![image-20220105184944295](https://i0.hdslb.com/bfs/album/180cd587b8b774d61e02832b53916c7ae7e02497.png)

### 链表

**优点：便于插入**

**循环链表：**

- **判空：`first->next == fisrt`**

## 第三章 栈与队列

### 栈

- **只允许在一端操作（插入和删除）的线性表**

- **后进先出 (LIFO)**

**双栈共享一个栈空间**

![image-20220105185634744](https://i0.hdslb.com/bfs/album/cfb06b19189a23331a575b7f3630de74d288dc55.png)

- **栈满：`t[0]+1 == t[1]`**
- **栈空：`b[0] == t[0] && t[1] == b[1]`**

**n个元素出栈顺序有几种？**

<img src="https://i0.hdslb.com/bfs/album/63634a96d76130c546a3fd99f7c6b5bed553bbc3.png" alt="image-20220105185925026" style="zoom:80%;" />

**表达式求解**

- **中缀(infix)表示** 
      <操作数> <操作符> <操作数>，如 A+B

- **前缀(prefix)表示**
      <操作符> <操作数> <操作数>，如 +AB

- **后缀(postfix)表示** 
       <操作数> <操作数> <操作符>，如 AB+

- eg：![image-20220105190727930](https://i0.hdslb.com/bfs/album/6cfa753e2b312abd484da2d5c129a67b703ea600.png)

- **前缀可以看作倒过来的后缀**

- **中缀转后缀表示**

  先对中缀表达式按运算优先次序**加括号**，再**把操作符后移到右括号的后面**并以就近移动为原则，最后将所有**括号消去**

  eg：<img src="https://i0.hdslb.com/bfs/album/9b664524b0044124ecc11256af1aa391627566e3.png" alt="image-20220105190928649" style="zoom:80%;" />

- **中缀转前缀表示**

  先对中缀表达式按运算优先次序通统**加括号**，再把**操作符前移到左括号前**并以就近移动为原则，最后将所有**括号消去**

  eg：<img src="https://i0.hdslb.com/bfs/album/cbb7d193324e24c5728397a7a3d0791ef6ea4b11.png" alt="image-20220105191052310" style="zoom:80%;" />

**将递归过程改为非递归算法：需要用到栈**



### 队列

- **只允许在一端删除，在另一端插入的线性表**
- **先进先出(FIFO, First In First Out)**

**顺序表上的循环队列：元素总数 maxSize，下标[0,maxSize-1]**

- **队头前进1：`front = (front+1)%maxSize`**
- **队尾前进1：`rear = (rear+1)%maxSize`**
- **队列初始化：`front = rear = 0`**
- **队空条件：`front == rear`**
- **队满条件：`(rear + 1)%maxSize == front`**



## 数组与广义表

### 特殊矩阵的压缩

为节约存储，只存**对角线及对角线以上（或对角线及对角线以下）的元素**，可称为上**三角（或下三角）矩阵** 

<img src="https://i0.hdslb.com/bfs/album/a04ba57915b6a979d62a330b0b22ed9beb8c6407.png" alt="image-20220105191636013" style="zoom:70%;" /><img src="https://i0.hdslb.com/bfs/album/e48f7434dfeeb76470fa6a8d83b7692e25d259bc.png" alt="image-20220105191652493" style="zoom:70%;" />

- **数组大小：n+(n-1)+ ··· +2+1 = n*(n-1)/2**

- **下三角矩阵**

  <img src="https://i0.hdslb.com/bfs/album/c64c4ee516231e9ee0a09ab2e79405faaf044a53.png" alt="image-20220105191834969" style="zoom:80%;" />

  ![image-20220105191939136](https://i0.hdslb.com/bfs/album/49abb2b7db84c333a8363bdef38858c9eae3ee66.png)

![image-20220105191954977](https://i0.hdslb.com/bfs/album/32a3395a1cae2ac247573906ed8ae27c63f4aaf1.png)

- **上三角矩阵**

  <img src="https://i0.hdslb.com/bfs/album/6224be33dc8479c4a7a5b1567811c30cc0d0867f.png" alt="image-20220105192205817" style="zoom:80%;" />

  ![image-20220105192143571](https://i0.hdslb.com/bfs/album/dd20bd1f598d5d3cd6992769ef4123e69fb8d39d.png)

![image-20220105192240689](https://i0.hdslb.com/bfs/album/361960729f9fddcb136c2f452efa2017a5608c0b.png)

![image-20220105192314786](https://i0.hdslb.com/bfs/album/1e9df787e928d17784983ae0c966ae6973959867.png)



**稀疏矩阵使用三元组来压缩：(i,j,a~ij~)**



### 广义表

**特性**

- **有次序性**
- **有深度**
- **可递归**
- **有长度**
- **可共享**

**广义表表示**

<img src="https://i0.hdslb.com/bfs/album/863c8ae1bf7cb7fe72aecc1c42012f5ccb8adb56.png" alt="image-20220105193224067" style="zoom:80%;" />

**结点定义**

<img src="https://i0.hdslb.com/bfs/album/9f7eb3cae88ebcc901e02bb446f4acc75a81c5ce.png" alt="image-20220105193252453" style="zoom:50%;" />

- 结点类型 utype：= 0, 表头；= 1, 原子数据； = 2, 子表
- 信息info：utype = 0时, 存放引用计数(ref)；utype = 1时, 存放数据值(value)；utype = 2时, 存放指向子表表头的指针(hlink)
- 尾指针tlink：utype = 0时, 指向该表第一个结点；utype $ \ne$ 0时, 指向同一层下一个表结点地址

eg:<img src="https://i0.hdslb.com/bfs/album/5230d257452245cd1473526bd4764554e26a3c4a.png" alt="image-20220105193428339" style="zoom:80%;" />



## 第五章 树与二叉树

### 二叉树

- 若二叉树结点的层次从 1 开始, 则在二叉树的**第 i 层最多有 $2^{i-1}$个结点**

- 深度为 k 的**二叉树最少有 k 个结点**，**最多有 $2^k-1$ 个结点**。( k≥1 )

- 对任何一棵二叉树，如果其**叶结点有 $n_0$个**, **度为 2 的非叶结点有 $n_2$ 个**,   则有$n_0＝n_2+ 1$

  **扩展：n叉树，度为 i 的结点个数为 $n_i$ 则 叶节点 $n_0 = 1+n_2+2*n_3+···+(i-1)*n_i$**

**满二叉树与完全二叉树**

<img src="https://i0.hdslb.com/bfs/album/1657a958edb69c26b0d4819db849329d1321a145.png" alt="image-20220105200844064" style="zoom:80%;" />

- **具有 n (n≥0) 个结点的完全二叉树的深度为 $[log_2(n+1)]$(向上取整)** 
- **若完全二叉树结点个数为n，则叶子节点为 $[2/n]$(向上取整)**

- **顺序存储完全二叉树**
  - **若i > 1, 则 i 的双亲为 $[i／2]$(向下取整)**
  - **若$2*i <= n$, 则 i 的左子女为 $2*i$**
  - **若$2*i+1 <= n$, 则 i 的右子女为 $2*i+1$**

**二叉树的前序和中序可唯一的确定一颗二叉树**

**二叉树有n个结点，可以构建几种二叉树（与出栈顺序相同）**

<img src="https://i0.hdslb.com/bfs/album/052a894f97252b0b993cb1c1290d6adfb559ae3a.png" alt="image-20220105202046455" style="zoom:80%;" />

**线索二叉树**

- 先写出二叉树的前\中\后序，再根据顺序将其连接

- **若结点的前驱或后继是子女结点不画出**



### 树与森林

**存储表示方法**

- **广义表表示**

<img src="https://i0.hdslb.com/bfs/album/067d6485c15726106d64650f22f13602e3f61e06.png" alt="image-20220105202531619" style="zoom:80%;" />

- **双亲表示**

<img src="https://i0.hdslb.com/bfs/album/f8dbaf93a4fac79de0330436547e6c73d6581558.png" alt="image-20220105202559925" style="zoom:80%;" />

- **子女链表示**

<img src="https://i0.hdslb.com/bfs/album/0a98316a1295324dc1283024b6f4decd01ff91c8.png" alt="image-20220105202631127" style="zoom:80%;" />

- **子女指针表示**

<img src="https://i0.hdslb.com/bfs/album/c8a49e70e3b0cadecf8c22e240812a560000be27.png" alt="image-20220105202711384" style="zoom:80%;" />

- **子女-兄弟表示**

<img src="https://i0.hdslb.com/bfs/album/8babb23d72a676d5d35f671e897c46ac10d96602.png" alt="image-20220105202744299" style="zoom:80%;" />

**树与转化为二叉树（转换完的二叉树无右节点）**

- 再兄弟结点之间加一条线
- 对每个结点，只保留它与第一个孩子的连线，抹去其他孩子的连线
- 以树根为轴心，顺时针旋转45度

<img src="https://i0.hdslb.com/bfs/album/45e16a815c9635ad0244fce791ac2340aa968f57.png" alt="image-20220105203456047" style="zoom:60%;" />

**森林转换为二叉树**

- 先将森林中每棵树转换为二叉树
- 将各个树的右节点与跟相连
- 以根为轴心，旋转45度

<img src="https://i0.hdslb.com/bfs/album/142b04acb53fe8eb4591a437fe38f122ef3bb54b.png" alt="image-20220105203702157" style="zoom:50%;" />

**树的先根遍历与对应二叉树的前序遍历相同**

**树的后根遍历与对应二叉树的中序遍历相同**

**树的广度优先（层次序）按对应二叉树斜45度一层一层遍历**

<img src="https://i0.hdslb.com/bfs/album/e4223a27b611e746fa5e5b211ef992e8b0a7f2d4.png" alt="image-20220105204508902" style="zoom:67%;" />

### 堆（具体在排序中讲）

<img src="https://i0.hdslb.com/bfs/album/2f2df5188081b234e8642f5ae6a944a2d54e1a2a.png" alt="image-20220105204831317" style="zoom:67%;" />

**以完全二叉树的顺序表示方式存储在一维数组中**

### Huffman树

**扩充二叉树（哈弗曼树是二叉树的一种）只有度为0和度为2的结点**

**扩充二叉树的带权路径长度定义为：树的各外结点到根的带权路径长度之和**

![image-20220105205157073](https://i0.hdslb.com/bfs/album/8f4c9aa57d27c9030c288b990015992beb5ec3fe.png)

eg：![image-20220105205209769](https://i0.hdslb.com/bfs/album/5f0234141815861d1de534c2c3404c7da8a01426.png)

**哈夫曼编码**

- 构造哈夫曼树
- 右结点为0，左为1

<img src="https://i0.hdslb.com/bfs/album/4608929855547580ca79885d2473818c57d2c22d.png" alt="image-20220105205536511" style="zoom:67%;" />

## 并查集与散列

### 散列表

- 使用**哈希函数（散列函数）**将**数据的存储位置与关键码**一一对应

- 对不同的关键码，通过散列函数的计算，得到了同一散列地址。这些关键码称为 **同义词**

- 散列表的两个重要问题：**哈希函数（散列函数）**，冲突解决方式

**散列函数**

- **直接定址法**
  $$
  Hash(key) = a*key+b \qquad  \{a, b为常数\}
  $$

- **数字分析法**

- **除留余数法（考试常考）**

  若散列表长度为m，则p最好取小于m的最大质数
  $$
  hash (key) = key\%p \qquad p \le  m
  $$

- **平方取中法**

  **标识符（ASCII码）的八进制内码表示及其平方值和散列地址**

  eg：<img src="https://i0.hdslb.com/bfs/album/c099b9ac609ec56616cd26c8e6cab29789c0d8f8.png" alt="image-20220105210729871" style="zoom:80%;" />

- **折叠法**

**处理冲突的方法**

- **闭散列法（开地址法）**

  - **线性探查法 (Linear Probing)（以除留余数法为例）**

    - 地址被占了，向后移动

    - 考察搜索平均长度
      - **搜索成功的平均长度，底为表中元素个数**
      - **搜索失败的平均长度：在表中找不到待查元素，但找到插入元素，底散列函数中的p**

  - **二次探查法**
    $$
    H_i = (H_0+i^2) \% m,  \quad	H_i = (H_0-i^2)\% m,\\
    i = 1, 2, 3, …, (m-1)/2
    $$
    

  - **双散列法**

    两个散列函数，Hash()计算桶号，一旦冲突ReHash()计算洗一个同的移位量

- **开散列法（链地址法）**

  各个桶中的表项通过一个**单链表**链接起来，称之为**同义词子表**



**开散列法优于闭散列法**

**除留余数法最好，折叠法最差**



## 第七章 搜索

### 静态搜索表

在数组中搜索

### 二叉搜索树

- 左子树（如果非空）上所有结点的关键码都小于根结点的关键码
- 右子树（如果非空）上所有结点的关键码都大于根结点的关键码
- 左子树和右子树也是二叉搜索树
- 二叉搜索树的**层序遍历**是所有元素的**升序排序**

**操作**

- **搜索：树高为h则最多比较次数不超过h次**
- **插入：只会插入叶结点**
- **删除：**
  - **删除叶结点**
  - **被删结点右子树为空：**左子女结点顶替
  - **被删结点左子树为空**：右子女结点顶替
  - **被删结点左、右子树都不为空：**右子树中寻找**中序下**的第一个结点(关键码最小)

### AVL树（高度平衡二叉搜索树）

- 为二叉搜索树
- 左子树和右子树的高度之差的绝对值不超过1
- 左子树和右子树都是 AVL 树
- **结点平衡因子：右子树高度-左子树高度**

**平衡化旋转**

- **单旋转**

  - **左单旋转**

    在结点A的右子女的右子树E中插入新结点，该**子树高度增1导致结点A的平衡因子变成2**，出现不平衡。为使树恢复平衡，从**A沿插入路径连续取3个结点A、C和E**，以**结点C为旋转轴，让结点A逆时针旋转**

    <img src="https://i0.hdslb.com/bfs/album/e896704b58619daea50565928f51927b531c51d1.png" alt="image-20220105220204368" style="zoom:80%;" />

  - **右单旋转**

    在结点A的左子女的左子树D上插入新结点使其**高度增1导致结点A的平衡因子增到-2**，造成不平衡。为使树恢复平衡，从**A沿插入路径连续取3 个结点A、B和D，以结点B为旋转轴**，将结点**A顺时针旋转**

    <img src="https://i0.hdslb.com/bfs/album/47a1faec25e2223cbc03921363734b437dd561f9.png" alt="image-20220105220449094" style="zoom:80%;" />

- **双旋转**

  - **先左后右双旋转** 

    在结点**A的左子女的右子树中插入新结点**，该子树高度增1导致**结点A的平衡因子变为-2**，	造成不平衡

    - 以结点**E为旋转轴，将结点B反时针旋转**，以E代替原来B的位置
    - 再以结点**E为旋转轴，将结点A顺时针旋转**。使之平衡化

    

    <img src="https://i0.hdslb.com/bfs/album/0535f9e7da4d0f705772af9a73f767539f7fd1c0.png" alt="image-20220105220827404" style="zoom:67%;" /><img src="https://i0.hdslb.com/bfs/album/c7de54bc750f727e155dfc8fab114b20ada5172e.png" alt="image-20220105220849675" style="zoom:67%;" />

  - **先右后左双旋转**

    在结点A的**右子女的左子树**中插入新结点，该子树高度增1。**结点A的平衡因子变为2，发生了不平衡**

    - 首先以结点**D为旋转轴，将结点C顺时针旋转**，以D代替原来C的位置
    - 再以结点**D为旋转轴，将结点A反时针旋转**，恢复树的平衡

    <img src="https://i0.hdslb.com/bfs/album/298a54d26ccea02b44e71117121e705f7d5f9958.png" alt="image-20220105221745152" style="zoom:80%;" />

    <img src="https://i0.hdslb.com/bfs/album/d4a6198427f28ef8a6fc566e4713338268215c88.png" alt="image-20220105221800524" style="zoom:80%;" />

**AVL树的操作**

- **插入：插入一个判断一下是否要旋转**

- **删除：按二叉搜索树删除方法删除，在判断是否需要旋转**

eg：<img src="https://i0.hdslb.com/bfs/album/628eec10b6e544459131945ff7296e0849774263.png" alt="image-20220105222133816" style="zoom:80%;" />

<img src="https://i0.hdslb.com/bfs/album/604dc20c357210b9ee04c85bd4535de2ea162f03.png" alt="image-20220105222145536" style="zoom:80%;" />

<img src="https://i0.hdslb.com/bfs/album/3e619935f25ccb234335e02678cc73a4d1ff03b4.png" alt="image-20220105222155136" style="zoom:80%;" />

## 第八章 图

**顶点的度为顶点的出度与入度之和**

- **连通图：无向图中所有结点都是联通的**

- **强连通图：有向图中所有结点都是联通的（n个结点，最少n条变）**
- **若连通图：有向图的无向图映像为连通图**

### 图的存储表示

**邻接矩阵：**

- 大小只与结点个数有关
- 列和为入度大小，行和为出度大小

- 适合存储稠密矩阵

**邻接表**

- 长度为结点个数的一个数组，每个元素为一个单链表

- 适合存储稀疏矩阵

### 最小生成树

**需要使用并查集判断是否来联通**

- **克鲁斯卡尔（Kruskal）算法**
  - **所有边都放入优先队列**

- **普里姆算法（Prim）算法**
  - 先将一个结点的所有边放入优先队列，再扩展结点

- **prim算法**适用于边**稠密的网络**
  **Kruskal算法不仅适合于边稠密的情形，也适合于边稀疏的情形**

### 最短路径

**Dijkstra算法，解决权值非负情形的单源最短路径问题**

按**路径长度的递增次序**， **逐步产生最短路径**。首先求出长度最短的一条最短路径，再参照它求出长度次短的一条最短路径，依次类推，直到从顶点v 到其它各顶点的最短路径全部求出为止

**算法规定三个数组：**

- **`bool S[n]`，判断1结点到下标结点，是否是最短路径**
- **`int dist[n]`，存放1结点到下标结点的最短路径长度**
- **`int degree[n]`，用来存放下标结点的入度个数**



**算法思想步骤**

1. 统计所有的结点的入度放入degree数组，S数组全部置为false，dist数组全部置无穷，dist[0] = 0，S[0]=true
2. 找出入度为0(degree[i]==0，等价于S[i] == true)的结点（起始为1结点），该结点的所有指向结点，计算路径长度，并使其入度-1
   - 若小于dist数组中存放的长度，更新
   - 若大于则不更新
   - 若指向结点的入度变为0，S表置true
3. 重复步骤2，直至所有结点均已遍历，dist数组中存放1结点到其他所有结点的最短路径



### AOV网络（活动网络，使用拓扑排序）

AOV网络无有向无环图

拓扑排序时间复杂度O(n+e)，e为边数



## 第九章 排序

### 插入排序

**直接插入排序**

- 最好情况下，待排元素有序只需比较 n-1 次

**折半插入排序插入**

- 再搜索时使用折半查找

**希尔排序**

- 时间复杂的不好统计
- 元素不一定放在正确位置
- 不稳定

### 交换排序

**冒泡排序**

- 元素有序是最快，比较n-1次

**快排**

- 平均时间复杂度最好的排序方法
- 元素有序时，时间复杂度$O(n^2)$，空间复杂度$O(n)$

### 选择排序

**直接选择排序**

- 选出最小元素与第一个元素交换
- 不稳定

### 堆排序

堆排序主要使用向下调整算法（siftdown）对堆进行调整

堆排序建立最大堆，一般为顺序存储

**过程**

- 给定一个数组，先调整为最大堆
  - 找到最后一个非叶结点$[n/2]$使用sifdown()算法对其调增，再向前进行调整，直到根节点

- 将根节点（最大元素），与堆最后一个元素交换，堆长度-1
- 再将堆的根结点使用 siftdown 算法

### 排序比较

![image-20220106122733357](https://i0.hdslb.com/bfs/album/6e122aa62feb4d3c3c98cfb8d52620a2769f1298.png)



## 各种数据结构的时间复杂度分析

$$
O(1)<O(log_2n)<O(n)<O(n\log_{}{n})<O(n^2)<O(n^3)<O(2^n)<O(n!)
$$

### 顺序表（SeqList）

使用 **数组** 存放数据

| 操作        | 时间复杂度                     |
| :---------- | :----------------------------- |
| 增(Insert)  | $O(n)$                         |
| 删(Remove)  | $O(n)$                         |
| 改(setData) | 已知索引$O(1)$，未知索引$O(n)$ |
| 查(Search)  | 已知索引$O(1)$，未知索引$O(n)$ |

### 单链表（LinkedList）

| 操作        | 时间复杂度      |
| :---------- | :-------------- |
| 增(Insert)  | $O(n)$          |
| 删(Remove)  | $O(n)$          |
| 改(setData) | $O(n)$ 未知索引 |
| 查(Search)  | $O(n)$ 未知索引 |
| 表头插入    | $O(1)$          |

### 数组和链表对比

数组最大的优点：支持随机访问、快速查询
数组最好用于索引有语义的情况

链表最大的优点：动态
链表不适合用于索引有语义的情况

### 顺序栈（SeqStack）

使用数组存储表示栈

| 操作                      | 时间复杂度  |
| ------------------------- | ----------- |
| 入栈(push)                | $O(1)$ 均摊 |
| 出栈(pop)                 | $O(1)$ 均摊 |
| 返回栈顶元素(peek)        | $O(1)$      |
| 获取栈中元素个数(getSize) | $O(1)$      |
| 判空(isEmpty)             | $O(1)$      |

### 链式栈（LinkedStack）

使用链表存储栈

| 操作                      | 时间复杂度 |
| ------------------------- | ---------- |
| 入栈(push)                | $O(1)$     |
| 出栈(pop)                 | $O(1)$     |
| 返回栈顶元素(peek)        | $O(1)$     |
| 获取栈中元素个数(getSize) | $O(1)$     |
| 判空(isEmpty)             | $O(1)$     |

### 顺序队列（SeqQueue）

使用数组存放队列

| 操作                    | 时间复杂度        |
| ----------------------- | ----------------- |
| 入队(enqueue)           | $O(1)$ 均摊       |
| 出队(dequeue)           | $O(n)$            |
| 取队头(front)           | $O(1)$            |
| 获取队列中元素(getSize) | $           O(1)$ |
| 判队空(isEmpty)         | $O(1)$            |

### 链表队列（LinkedQueue）

使用链表存放队列

| 操作                    | 时间复杂度 |
| ----------------------- | ---------- |
| 入队(enqueue)           | $O(1)$     |
| 出队(dequeue)           | $O(1)$     |
| 取队头(front)           | $O(1)$     |
| 获取队列中元素(getSize) | $O(1)$     |
| 判队空(isEmpty)         | $O(1)$     |

### 优先队列（PQueue）

| 实现方式 | 入队             | 出队（拿出最大元素） |
| -------- | ---------------- | -------------------- |
| 数组     | $O(1)$           | $O(n)$               |
| 链表     | $O(n)$           | $O(1)$               |
| 堆       | $O(\log_{}{n} )$ | $O(\log_{}{n} )$     |

### 堆（BinaryHeap）

使用二叉树实现的最小堆

| 操作                     | 时间复杂度       | 备注                |
| ------------------------ | ---------------- | ------------------- |
| 建堆(MakeHeap_Void)      | $O(1)$           | 建空堆              |
| 建堆(MakeHeap_List)      | $O(n)$           | 根据已有序列建立堆  |
| 插入元素(Insert)         | $O(\log_{}{n} )$ |                     |
| 删除元素(Delete)         | $O(\log_{}{n} )$ |                     |
| 修改(DecreaseKey)        | $O(\log_{}{n} )$ | 修改某个元素的key值 |
| 取堆顶(FindMin)          | $O(1)$           |                     |
| 取堆顶并删除(ExtractMin) | $O(\log_{}{n} )$ | 删除堆顶            |
| 合并堆(Union)            | $O(n)$           | 合并两个堆          |

### 基本图算法

使用邻接图存储图

| 算法                                 | 时间复杂度                   |
| ------------------------------------ | ---------------------------- |
| Prime                                | $O(n^2)$                     |
| Prime（使用堆排序）                  | $O(n\log_{}{m})$ 结果有m个边 |
| Kruskal                              | $O(n\log_{}{n} )$            |
| Dijkstra                             | $O(n^2)$                     |
| 拓扑排序（使用临界表，n个结点e个弧） | $O(n+e)$                     |

