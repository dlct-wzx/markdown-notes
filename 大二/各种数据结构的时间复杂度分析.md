# 各种数据结构的时间复杂度分析

[TOC]


$$
O(1)<O(log_2n)<O(n)<O(n\log_{}{n})<O(n^2)<O(n^3)<O(2^n)<O(n!)
$$


## 顺序表（SeqList）

使用 **数组** 存放数据

| 操作        | 时间复杂度                     |
| :---------- | :----------------------------- |
| 增(Insert)  | $O(n)$                         |
| 删(Remove)  | $O(n)$                         |
| 改(setData) | 已知索引$O(1)$，未知索引$O(n)$ |
| 查(Search)  | 已知索引$O(1)$，未知索引$O(n)$ |

## 单链表（LinkedList）

| 操作        | 时间复杂度      |
| :---------- | :-------------- |
| 增(Insert)  | $O(n)$          |
| 删(Remove)  | $O(n)$          |
| 改(setData) | $O(n)$ 未知索引 |
| 查(Search)  | $O(n)$ 未知索引 |
| 表头插入    | $O(1)$          |

## 数组和链表对比

数组最大的优点：支持随机访问、快速查询
数组最好用于索引有语义的情况

链表最大的优点：动态
链表不适合用于索引有语义的情况

## 顺序栈（SeqStack）

使用数组存储表示栈

| 操作                      | 时间复杂度  |
| ------------------------- | ----------- |
| 入栈(push)                | $O(1)$ 均摊 |
| 出栈(pop)                 | $O(1)$ 均摊 |
| 返回栈顶元素(peek)        | $O(1)$      |
| 获取栈中元素个数(getSize) | $O(1)$      |
| 判空(isEmpty)             | $O(1)$      |

## 链式栈（LinkedStack）

使用链表存储栈

| 操作                      | 时间复杂度 |
| ------------------------- | ---------- |
| 入栈(push)                | $O(1)$     |
| 出栈(pop)                 | $O(1)$     |
| 返回栈顶元素(peek)        | $O(1)$     |
| 获取栈中元素个数(getSize) | $O(1)$     |
| 判空(isEmpty)             | $O(1)$     |

## 顺序队列（SeqQueue）

使用数组存放队列

| 操作                    | 时间复杂度        |
| ----------------------- | ----------------- |
| 入队(enqueue)           | $O(1)$ 均摊       |
| 出队(dequeue)           | $O(n)$            |
| 取队头(front)           | $O(1)$            |
| 获取队列中元素(getSize) | $           O(1)$ |
| 判队空(isEmpty)         | $O(1)$            |

## 链表队列（LinkedQueue）

使用链表存放队列

| 操作                    | 时间复杂度 |
| ----------------------- | ---------- |
| 入队(enqueue)           | $O(1)$     |
| 出队(dequeue)           | $O(1)$     |
| 取队头(front)           | $O(1)$     |
| 获取队列中元素(getSize) | $O(1)$     |
| 判队空(isEmpty)         | $O(1)$     |

## 优先队列（PQueue）

| 实现方式 | 入队             | 出队（拿出最大元素） |
| -------- | ---------------- | -------------------- |
| 数组     | $O(1)$           | $O(n)$               |
| 链表     | $O(n)$           | $O(1)$               |
| 堆       | $O(\log_{}{n} )$ | $O(\log_{}{n} )$     |

## 堆（BinaryHeap）

使用二叉树实现的最小堆

| 操作                     | 时间复杂度       | 备注                |
| ------------------------ | ---------------- | ------------------- |
| 建堆(MakeHeap_Void)      | $O(1)$           | 建空堆              |
| 建堆(MakeHeap_List)      | $O(n)$           | 根据已有序列建立堆  |
| 插入元素(Insert)         | $O(\log_{}{n} )$ |                     |
| 删除元素(Delete)         | $O(\log_{}{n} )$ |                     |
| 修改(DecreaseKey)        | $O(\log_{}{n} )$ | 修改某个元素的key值 |
| 取堆顶(FindMin)          | $O(1)$           |                     |
| 取堆顶并删除(ExtractMin) | $O(\log_{}{n} )$ | 删除堆顶            |
| 合并堆(Union)            | $O(n)$           | 合并两个堆          |

## 基本图算法

使用邻接图存储图

| 算法                                 | 时间复杂度                   |
| ------------------------------------ | ---------------------------- |
| Prime                                | $O(n^2)$                     |
| Prime（使用堆排序）                  | $O(n\log_{}{m})$ 结果有m个边 |
| Kruskal                              | $O(n\log_{}{n} )$            |
| Dijkstra                             | $O(n^2)$                     |
| 拓扑排序（使用临界表，n个结点e个弧） | $O(n+e)$                     |



## 排序（Sort）

| 方法               | 平均时间          | 有序序列 | 最差情形          | 稳定度 | 额外空间         | 备注                           |
| ------------------ | ----------------- | -------- | ----------------- | ------ | ---------------- | ------------------------------ |
| 冒泡(BubbleSort)   | $O(n^2)$          | $O(n)$   | $O(n^2)$          | 稳定   | $O(1)$           | n小时好                        |
| 交换(ExchangeSort) | $O(n^2)$          |          | $O(n^2)$          | 不稳定 | $O(1)$           | n小时好                        |
| 选择(SelectSort)   | $O(n^2)$          |          | $O(n^2)$          | 不稳定 | $O(1)$           | n小时好                        |
| 插入(InsertSort)   | $O(n^2)$          | $O(n)$   | $O(n^2)$          | 稳定   | $O(1)$           | 大部分已排好                   |
| 希尔(ShellSort)    | $O(n\log_{}{n} )$ |          | $O(n^s)$          | 不稳定 | $O(1)$           | $1<s<2$                        |
| 快速(QuickSort)    | $O(n\log_{}{n} )$ | $O(n^2)$ | $O(n^2)$          | 不稳定 | $O(n\log_{}{n})$ | n大时好                        |
| 归并(MergeSort)    | $O(n\log_{}{n} )$ |          | $O(n\log_{}{n} )$ | 稳定的 | $O(n)$           | n大时好                        |
| 堆(HeapSort)       | $O(n\log_{}{n} )$ |          | $O(n\log_{}{n} )$ | 不稳定 | $O(1)$           | n大时好                        |
| 基数(RadixSort)    | $O(\log_{R}{B})$  |          | $O(\log_{R}{B})$  | 稳定   | $O(n)$           | B为真数(0···9),R是基数(十百千) |

