# 软件体系结构

[TOC]

# 第一章 绪论

**软件体系结构思想诞生与1960s**

## 1.1 什么是软件体系结构

软件体系结构是具有一定形式的结构化元素，抽象的讲，软件体系结构包括构成系统的设计元素的描述，设计元素的交互，设计元素组合的模式，以及在这些模式中的约束

**软件体系结构 = 组件 + 连接件 + 约束**

 **组件**：具有某种功能的**可重用的软件模块单元**，表示了系统中**主要的计算单元和数据存储**

 **连接件**：表示了组件之间的交互，简单的连接件有：**管道，过程调用，事件广播**等，复杂的连接件有：**客户 - 服务器通信协议，数据库和应用之间 SQL 连接**等

 **约束**：表示了组件和连接件的**拓扑逻辑和约束**

## 1.2 软件重用（软件重用就是为了解决软件危机）

 软件重用是指在**两次或多次不同的软件开发过程中重复使用相同或相近软件元素**的过程

**软件重用的意义**

- 提高软件生产率，降低开发成本；
- 有助于改善质量；
- 提高软件的灵活性和标准化程度

## 1.3 软件危机

软件危机是指在计算机软件的**开发（development）和维护（maintenance）过程中遇到的一系列严重问题**

**软件危机的表现**

- **软件开发进度难以预测**
- **软件开发成本难以控制**
- **用于对产品的功能难以满足**
- **软件产品质量无法保证**
- **软件产品难以维护**

**软件危机的成因**

- 用户需求不明确
- 缺乏正确的理论指导
- 软件规模越来越大
- 软件复杂度越来越高

**如何克服软件危机**

人们面临的不仅是技术问题，更重要的是管理问题。应用现代工程的概念、原理、技术、方法进行计算机软件的开发、管理和维护

软件工程是用工程、科学、数学的原则与方法研制、维护计算机软件的有关技术以及管理方法。三要素：方法、工程、过程。

## 1.4 软件体系结构在软件生命周期中的作用

**在各个阶段都是起作用的**

![image-20221124162912643](https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20221124162912643.png)



# 第二章 软件体系结构的风格和模式

## 2.1 软件体系结构风格不能作为软件分类的标准

体系结构风格不是对软件进行分类的标准，它仅仅是表示描述软件的不同角度而已。例如一个系统采用了分层风格，但这并不妨碍它用面向对象的方法来实现。同一个系统采用多种风格造成了所谓体系结构风格的异构组合

**使用体系风格的优点**

- 促进设计重用
- 使代码被重用
- 使系统组成更易于被其他人理解

## 2.2 列举典型的体系结构风格

- **管道过滤器风格**
- **主程序/子程序风格**
- **事件驱动风格**
- **分层风格**
- **面向对象风格**
- **解释器风格**
- **基于规则的系统风格**
- **仓库风格**
- **黑板系统风格**
- **C2风格**
- **客户机/服务器风格**
- **浏览器/服务器风格**
- **正交架构风格**
- **云体系结构风格**
- **网格计算体系结构风格**
- **异构风格的集成**

## 2.3每种体系结构的优缺点、典型应用和特点

### 管道过滤器风格

**惯用模式**：

主要包括过滤器和管道两种元素。在这种结构中，构件被称为过滤器，负责对数据进行加工处理。每个过滤器都有一组输入端口和输出端口，从输入端口接收数据，经过内部加工处理之后，传送到输出端口上。数据通过相邻过滤器之间的连接件进行传输，连接件可以看作输入数据流和输出数据流之间的通路，这就是管道

- 过滤器是独立运行的构件
- 过滤器对其处理上下连接的过滤器“无知”
- 结果的正确性不依赖于各个过滤器运行的先后次序

**原理图**：

![img](https://img-blog.csdnimg.cn/20191222102559229.png)

**优点**：

1. 简单性。
2. 支持复用。
3. 系统具有可扩展性和可进化型。
4. 系统并发性（每个过滤器可以独立运行，不同子任务可以并行执行，提高效率）。
5. 便于系统分析。

**缺点**：

1. 系统处理工程是批处理方式。
2. 不适合用来设计交互式应用系统。
3. 由于没有通用的数据传输标准，因此每个过滤器都需要解析输入数据和合成数据。
4. 难以进行错误处理。

**应用**：

- ASP.net管道模型

- **传统的编译器就是管道/过滤器体系结构风格的一个实例** 编译器由词法分析、语法分析、语义分析、中间代码生成、中间代码优化和目标代码生成几个模块组成，一个模块的输出是另一个模块的输入。源程序经过各个模块的独立处理之后，最终将产生目标程序。编译器的框架结构如图：

![img](https://img-blog.csdnimg.cn/20191222102923143.png)

**管道/过滤架构脆弱性分析**

- 每个过滤器的输入输出是独立的，一个过滤器的输出做为另外一个过滤器的输入，耦合度低
- 若攻击者知道了某个过滤器的输入输出，有可能得出过滤器的功能，从而对系统的安全性造成威胁
- 由于一个过滤器的输出作为另外一个过滤器的输入，若一个过滤器发生错误，使得整个错误在系统中放大，从而威胁系统的稳定性

### 主程序/子程序风格

**结构化设计的典型风格**

**管用模式**：

组件为主程序和子程序，连接件为调用-返回机制，拓扑结构为层次化结构

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129112723613.png" alt="image-20230129112723613" style="zoom:80%;" />

**优点**：

1. 具有很高的数据访问效率，因为计算共享同一个存储区
2. 不同的计算功能被划分在不同的模块中

**缺点**：

该方案在处理变更的能力上有许多严重的缺陷

1. 对数据存储格式的变化将会影响几乎所有的模块
2. 对处理流程的改变与系统功能的增强也很难适应
3. 方案难以支持有效的复用

### 事件驱动风格

**惯用模式**：

事件驱动就是在当前系统的基础之上，根据事件声明和发展状况来驱动整个应用程序运行。

事件驱动体系结构的基本思想是：**系统对外部的行为表现可以通过它对事件的处理来实现**。在这种体系结构中，**构件不再直接调用过程，而是声明事件**。系统其他构件的过程可以在这些事件中进行注册。**当触发一个事件的时候，系统会自动调用这个事件中注册的所有过程**。因此，触发一个事件会引起其他构件的过程调用。

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129113553124.png" alt="image-20230129113553124" style="zoom:80%;" />

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129113124049.png" alt="image-20230129113124049" style="zoom:67%;" />

**特征**：

1. 系统是由若干子系统或元素所组成的一个整体
2. 在某一种消息机制的控制下，系统作为**一个整体与环境相适应**和协调
3. 在一个系统的若干子系统中，必定有**一个子系统起着主导作用**，而其他子系统则处于从属地位
4. 任一系统和系统内的任一元素，都有**1个事件收集机制（监听器）和1个事件处理机制（控制器）**，通过这种机制与周围环境发生作用和联系

**优点**：

1. 事件声明者不需要知道哪些构件会响应事
2. 提高了软件复用能力
3. 便于系统升级

**缺点**：

1. 构件放弃了对计算的控制权，完全由系统来决定
2. 存在数据共享问题
3. 对象逻辑复杂

**应用**：

（1）在程序设计环境中用于集成各种工具

（2）在数据库管理系统中用于检查数据库的一致性约束条件

（3）在用户界面中分离数据和表示

（4）在编辑器中支持语法检查

- Java中的button实现

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129113323317.png" alt="image-20230129113323317" style="zoom:67%;" />

- Spring

**事件驱动风格和面向对象风格的关系**

基于面向对象风格的系统由多个封装起来的对象构成，对象之间通过消息传递实现通信，而事件驱动正是对消息传递机制的一种实现。所以基于事件驱动风格的系统往往都是面向对象的

**时间驱动架构脆弱性分析**

- 组件削弱了自身对系统的控制能力。一个组件触及事件时，并不能确定响应该事件的其他组件及各组件的执行顺序
- 不能很好地解决数据交换问题
- 使系统中各组件的逻辑关系变得更加复杂
- 事件驱动容易进入死循环，这是编程逻辑决定的
- 虽然有机会实现有效利用cpu，但也存在高并发事件处理的可能造成系统响应问题, 且易导致系统数据不正确、丢失数据现象
- 因为可响应的流程基本都是固定的，如果操作不当，容易引发安全问题

### 分层风格

**惯用模式**：

- 在分层风格中，系统将划分为一个**层次结构**。
- 每一层都具有高度的内聚性，包含抽象程度一致的各种构件，支持信息隐藏。

- 分层有助于将复杂系统划分为独立的模块，从而简化程序的设计和实现。
- 通过分解，可以将系统功能划分为一些具有明确定义的层，较高层是面对特定问题，较低层具有一般性。

**每层都为上层提供服务，同时又利用了下层的逻辑功能**。在分层体系结构中，每一层只对相邻层可见。层次之间的连接件是协议和过程调用。用以实现各层之间的交互。

 

原理图：

![img](https://img-blog.csdnimg.cn/20191222103354587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

**优点**：

1. 分层风格支持系统设计过程中的**逐级抽象**
2. 基于分层风格的系统具有较好的**可扩展性**
3. 分层风格支持**软件复用**

**缺点**：

1. 并非所有系统都能够按照层次来进行划分。
2. 很难找到一种合适和正确的层次划分方法。
3. 在传输数据是，需要经过多个层次。
4. 多层结构难以调试。

**应用**：

- 计算机网络架构

- .Net平台

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129114337563.png" alt="image-20230129114337563" style="zoom:67%;" />

**分层架构脆弱性分析**

- 一旦某个底层发生错误，那么整个程序将会无法正常运行，产生一些数据溢出、空指针、空对象的安全性问题，也有可能会得出错误的结果
- 将系统隔离为多个相对独立的层，要求在层与层之间引入通信机制。在使用面向对象方法设计的系统中，通常会存在大量细粒度的对象，以及它们之间的大量的消息交互——对象成员方法的调用。本来直来直去的操作，现在要层层传递，势必造成性能的下降

### 面向对象风格

**惯用模式**：

在面向对象体系结构中，软件工程的模块化、信息隐藏、抽象和重用原则得到了充分的体现。在这种体系结构中，数据表示和相关原语操作都被封装在抽象数据类型中。在这种风格中，对象是构件，也成为抽象数据类型的实例。对象与对象之间，通过函数调用和过程调用来进行交互。

**原理图**：

![img](https://img-blog.csdnimg.cn/20191222103103145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

**优点**：

1. 高度模块性
2. 封装功能
3. 代码共享
4. 灵活性
5. 易维护性

**缺点**：

1. 如果一个对象要调用另一个对象，则必须知道它的标识和名称
2. 会产生连锁反应

**应用**：

- 面向对象的体系结构模式适用于**数据和功能分离的系统**中，同样也适合于问题域模型比较明显，或需要人机交互界面的系统。**大多数应用事件驱动风格的系统也常常应用了面向对象风格**

### 解释器风格（虚拟机风格）

**惯用模式**：

- **解释器风格的系统核心在于虚拟机**
- 一个基于解释器风格的系统通常包括：正在被解释执行的伪码和解释引擎；
- 伪码：由需要被解释执行的源代码和解释引擎分析所得的中间代码组成；
- 解释引擎包括：语法解释器和解释器当前的运行状态

解释器作为一种体系结构，主要用于构建虚拟机，用以弥合程序语义和计算机硬件之间的间隙。实际上，解释器是利用软件来创建的一种虚拟机，因此，解释器风格又被称为虚拟机风格。

**原理图**：

![img](https://img-blog.csdnimg.cn/20191222105003331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

**优点**：

1. 在文法规则比较简单的情况下，解释器风格工作的很好
2. 易于改变和扩展文法。因为解释器风格使用类来表示文法规则，用户可以使用继承来改变和扩展文法。已有的表达式可以采用增量的方式逐渐扩充，而新的表达式可以定义为旧表达式的变体；
3. 易于实现文法

**缺点**：

1. 无法解释复杂的文法规则
2. 由于使用了特定了语言和自定义操作规则，因此增加了系统运行的开销
3. 应用范围较窄

**应用**：

- 布尔表达式解释器
- Javascript 语言解释器JlBrowers
- <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134119953.png" alt="image-20230129134119953" style="zoom:67%;" />
- <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134058474.png" alt="image-20230129134058474" style="zoom: 67%;" />

### 基于规则的系统风格

**惯用模式**：

- 将频繁变化的业务逻辑抽离出来，形成独立的规则库
- 系统运行时，读取规则库，根据运行状态控制系统运行流程
- 使用模式匹配搜索来寻找规则并在正确的时候应用正确的逻辑知识的虚拟机
- 基于规则系统提供了一种基于专家系统解决问题的手段，将知识表示为“条件-行为”的规则，当满足条件时触发相应的行为

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134853421.png" alt="image-20230129134853421" style="zoom:80%;" />

**优缺点与解释器风格相同**

**优点**：

1. 在文法规则比较简单的情况下，解释器风格工作的很好
2. 易于改变和扩展文法。因为解释器风格使用类来表示文法规则，用户可以使用继承来改变和扩展文法。已有的表达式可以采用增量的方式逐渐扩充，而新的表达式可以定义为旧表达式的变体；
3. 易于实现文法

**缺点**：

1. 无法解释复杂的文法规则
2. 由于使用了特定了语言和自定义操作规则，因此增加了系统运行的开销
3. 应用范围较窄

**应用**：

- 基于规则的专家系统

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134835406.png" alt="image-20230129134835406" style="zoom:67%;" />

### 仓库风格

**基本思想**：

- 仓库是存储和维护数据的中心场所
- 仓库式风格的两种组件：中央数据结构组件件、相对独立的组件集合

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134947421.png" alt="image-20230129134947421" style="zoom:67%;" />

**优点**：

​	便于模块间的数据共享，方便模块的添加、更新和删除，避免了知识源的不必要的重复存储等

**缺点**：

​	对于各个模块，需要一定的同步/加锁机制保证数据结构的完整性和一致性等

**应用**：

- **现代编译器**

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129135132635.png" alt="image-20230129135132635" style="zoom:50%;" />

- 基于仓库风格的软件研发环境Eclipse

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129135149034.png" alt="image-20230129135149034" style="zoom:50%;" />

### 黑板系统风格

**基本思想**：

- 传统上被用于信号处理方面进行复杂解释的应用程序，以及松散耦合的组件访问共享数据的应用程序
- 黑板架构实现的基本出发点是已经存在一个对公共数据结构进行协同操作的独立程序集合

**组成部分：知识源、黑板数据结构、控制器**

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129135433387.png" alt="image-20230129135433387" style="zoom:67%;" />

**优点**：

- 便于多客户共享大量数据，他们不关心数据何时有的、谁提供的、怎样提供的
- 既便于添加新的作为知识源代理的应用程序，也便于扩展共享的黑板数据结构
- 知识源可重用
- 支持容错性和健壮性

**缺点**：

- 不同的知识源代理对于共享数据结构要达成一致，而且，这也造成对黑板数据结构的修改较为困难——要考虑到各个代理的调用
- 需要一定的同步/加锁机制保证数据结构的完整性和一致性，增大了系统复杂度

**应用**：

- 需要解决冲突并处理可能存在的不确定性
- 需要从原始数据向高层结构转换的应用问题，如图、表、视觉、图像识别、语音识别、预警等
- 当把整个问题分解成子问题，每个子问题涵盖了不同领域知识和解决方法

**黑板模式脆弱性分析**

- 不能确保期望结果
- 复杂，效率低下
- 不支持并行

### C2风格

**通过连接件绑定在一起的按照一组规则运作的并行组件网络**

**惯用模式**：

- C2结构是一个层次网络，包括构件和连接件两种软件元素
- 构件和连接键都是包含顶部和底部的软件元素
- 构件和构件之间只能通过连接件进行连接，而连接件之间则可以直接进行连接
- 构件的顶部、底部分别与连接件的底部、顶部连接，连接件的顶部、底部也分别与连接件的底部、顶部连接

在C2体系结构中，构件之间的所有通信必须使用消息传递机制来实现。构件之间所有传递的信息可以分为两种，**一种是向上层构件发出服务请求的请求消息**，另一种是**向下层构件发出指示状态变化的通知消息**。**连接件负责消息的过滤、路由、广播、通信和相关处理**。

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129135715342.png" alt="image-20230129135715342" style="zoom:50%;" />

**优点**：

1. 可以使用任何编程语言来开发构件，构件重用和替换比较容易实现
2. 具有一定的扩展能力，可以有多种不同粒度的构件
3. 构件不需要共享地址空间，避免了共享全局变量所造成的复杂关系
4. 可实现多个用户和多个系统之间的交互
5. 在C2体系结构中，可以使用多个工具集和多种媒体类型，能够动态地更新系统的框架结构

**缺点**：

1. 不太适合大规模流式风格系统，以及对数据库使用比较频繁的应用

### 客户机/服务器风格（C/S体系结构）

- 客户机(Client，前端，front-end)：业务逻辑、与服务器通讯的接口；
- 服务器(Server，后端：back-end)：与客户机通讯的接口、业务逻辑、数据管理

原理图：

![img](https://img-blog.csdnimg.cn/2019122211140329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129140642251.png" alt="image-20230129140642251" style="zoom:80%;" />

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129140653279.png" alt="image-20230129140653279" style="zoom:80%;" />



![img](https://img-blog.csdnimg.cn/2019122211140349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129140718904.png" alt="image-20230129140718904" style="zoom:80%;" />

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129140756789.png" alt="image-20230129140756789" style="zoom:80%;" />

**应用：微信、QQ、支付宝**

**C/S架构脆弱性分析**

- 客户端需要安装专用的客户端软件，系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高
- 高昂的维护成本且投资大
- 传统的C/S结构的软件需要针对不同的操作系统系统开发不同版本的软件，由于产品的更新换代十分快，代价高和低效率已经不适应工作需要

### 浏览器/服务器风格（B/S体系结构）

**惯用模式**：

- **B/S结构是三层C/S体系结构的一种实现方式，主要包括浏览器，Web服务器和数据库服务器**
- B/S结构主要利用不断成熟的WWW技术，结合浏览器的多脚本语言，采用通用浏览器来实现原来需要复杂的专用软件才能实现的强大功能，节约了开发成本。
- B/S体系结构的核心是Web服务器，可以将应用程序以网页的形式存放在Web服务器上。
- 当用户运行某个应用程序时，只需要在可以断的浏览器中输入响应的 URL，向 Web 服务器提出 HTTP 请求。
- 当Web 服务器接收 HTTP 请求之后，会调用相关的应用程序（Servlets），同时向数据库服务器发送数据操作请求。
- 数据库服务器对数据操作请求进行响应，将结果返回给Web服务器的应用程序
- Web服务器应用程序执行业务处理逻辑，利用 HTML 来封装操作结果，通过浏览器呈现给用户。在B/S结构中，**数据请求、网页生成、数据库访问和应用程序执行全部由Web 服务器来完成**。

**原理图**：

![img](https://img-blog.csdnimg.cn/2019122210574818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pheXBob25lMTc=,size_16,color_FFFFFF,t_70)

**优点**：

1. 客户端只需要安装浏览器，操作简单。
2. 运用HTTP标准协议和统一客户端软件，能够实现跨平台通信。
3. 开发成本比较低，只需要维护Web服务器程序和中心数据库。

**缺点**：

1. 个性化程度比较低，所有客户端程序的功能都是一样的。
2. 客户端数据处理能力比较差。
3. 在B/S结构的系统中，数据提交一般以页面为单位，动态交互性不强，不利于在线事务处理。
4. B/S体系结构的可扩展性比较差，系统安全性难以保障。
5. B/S结构的应用系统查询中心数据库，其速度要远低于C/S体系结构。

**B/S结构脆弱性分析**

- 相对客户端来说，页面通用化，不突出个性。而且页面需要不断地动态刷新，尤其是当用户增多，网速慢等情况，服务器的压力将会增大，加载时间会变长。由于不需要安装客户端，客户端易扩展，B/S将面对大量的不可知用户
- 相对服务器来说，当用户增多时，服务器响应速度慢。功能虽然多样化，但是不能专门化，不能实现复杂的功能。服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想

### 正交架构风格

**惯用模式**：

- 正交体系结构是一种以 **垂直线索构件族** 为基础的层次化结构，包括**组织层**和 **线索**
- 在每一个组织层中，都包含具有相同抽象级别的构件。
- 线索是子系统的实例，是由完成不同层次功能的构件通过相互调用而形成的，每一条线索完成系统的一部分相对独立的功能
- 在正交体系结构中，每条线索的实现与其他线索的实现无关或关联很少。在同一层次中，构件之间不存在相互调用关系
- 

**原理图**：

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129143853320.png" alt="image-20230129143853320" style="zoom:80%;" />

**优点**：

1. 结构清晰，易于理解
2. 便于修改和维护
3. 可移植性强

**缺点**：

1. 实际应用中，并不是所有软件系统都能完全正交化，或者有时完全正交化的成本太高
2. 实际应用中，必须反复权衡进一步正交化的额外开销与所得到的更好的性能之间的关系

**应用**：

- 汽修服务管理系统

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144040695.png" alt="image-20230129144040695" style="zoom:50%;" />

### 云体系结构风格

**基本思想**：

- 利用非本地或远程服务器（集群）的分布式计算机为互联网用户提供服务（计算、存储、软硬件等服务）。这使得用户可以将资源切换到需要的应用上，根据需求访问计算机和存储系统

**原理图**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144143891.png" alt="image-20230129144143891" style="zoom:80%;" />

**优缺点**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144209045.png" alt="image-20230129144209045" style="zoom:67%;" />

**应用**

- 阿里云
- Hadoop

### 网格计算体系结构风格

- 网格计算风格属于分布式架构的一种
- 网格计算主要思想是利用各种分布在不同地点的资源来完成一个庞大到无法被一个机器实现的任务。
- 资源可以是任何被任务需要的资源，包括计算资源，存储资源和各类传感器等

**原理图**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144320925.png" alt="image-20230129144320925" style="zoom:77%;" />

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144605222.png" alt="image-20230129144605222" style="zoom:67%;" />

**主要面向目标**

- **资源和服务的无缝聚合**：容量聚合与能力聚合
- **普适服务架构**：使用统一的方法 发现 和 利用不同类型和不同地域的资源
- **自发行为**

**优点**

- 网格计算风格可以让应用程序具有分布式的计算能力。通过分布式的网格计算技术可以让应用程序可以获得更快的执行速度
- 因为虚拟组织技术，应用具有很高的安全性能，即使某几个计算几点瘫痪，也可以通过协作层的协议来进行恢复
- 网格计算风格相对于云计算架构来说需要的资源更加便宜，成本比较小，主要原因是网格计算的跨组织性，可以使得各类资源更不易被浪费

**缺点**

- 网格计算风格的缺点在于此架构风格不是任何程序都适用
- 不是非常稳定

**应用**：分布式计算

### 异构风格的集成

**基本思想**

- 在设计软件系统时，从不同角度来观察和思考问题，会对架构风格的选择产生影响
- 在实际应用中，各种软件架构并不是独立存在的，在一个系统中，往往会有多种架构共存和相互融合，形成更复杂的框架结构，即异构架构
- **组合方式**
  - 使用层次结构
  - 允许单一组件使用复合的连接件

**优缺点**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144904280.png" alt="image-20230129144904280" style="zoom:80%;" />

**应用：B/S架构和C/S架构组合**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129144940176.png" alt="image-20230129144940176" style="zoom:67%;" />

## 2.4 解释器风格域基于规则的风格的异同点

| **基于规则的系统** | **解释器风格**           |
| ------------------ | ------------------------ |
| 知识库             | 待解释的程序（伪码）     |
| 规则解释器         | 解释器引擎               |
| 规则与数据元素选择 | 解释器引擎内部的控制状态 |
| 工作内存           | 程序当前的运行状态       |

![](https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129134715380.png)

## 2.5 云体系结构和网格体系结构的异同段

- 网格计算和云计算**非常相关，但是并不相同**
- 云计算考虑的情形是利用本地终端访问互联网并且将高计算需求的任务放到云端集群，以完成个人用户的高计算任务
- 网格计算风格设计侧重在让各种异构的平台资源可以协同工作以及用户端对可利用资源的发现。

# 第三章 软件体系结构描述

## 3.1 形式化描述方法

**软件体系结构和软件体系结构描述不同的两个概念**

- **软件体系结构是附属于系统之中**。只要存在系统，体系结构就存在

  如：每个石头都会有重量

- 软件体系结构描述是**将体系结构可视化的手段和产物**

  如：表示一个石头的重量

**使用不同的策略和方法对同一软件体系结构做出不同的理解和描述**

**体系结构描述方式的标准**

- 语义丰富性
- 语义精确性
- 形式化程度

**主要描述方式**

- **非标准的图形符号——UML**
- **模块内联语言——MIL**
- **基于软构建的描述语言——CDL**
- **基于体系结构的描述语言——ADL**

## 3.2 软件结构描述的方式

### 3.2.1 非标准图形符号描述——UML

用由矩形框和有向线段组合而成的图形表达工具。其中，矩形框代表抽象构件，有向线段代表辅助各构件进行通讯、控制或关联的连接件

**特点**

- 语义丰富

- 语义极不精确

- 没有形式化基础

**用途**

- 商业展示

- 设计草图

**优点**

- 直观形象
- 简单

**缺点**

- 由于其术语和表达语义上存在着一些不规范和不精确，从而使得以矩形为基础的传统图形表达方法在不同系统和不同文档之间存在着许多不一致甚至矛盾

### 3.2.2 模块内联语言——MIL

**一种或多种传统程序设计语言模块连接起来描述软件的体系结构的方法**

**特点**

- 语义比较丰富，但局限在实现级别，层次较低
- 语义精确，有编译器作保证
- 没有或极少有形式化基础

**优点**

- 具有严格的语义基础，能够支持对较大的软件单元进行诸如：定义/使用（Definition/Use）、接口定义（Interface Definition）和导入/导出（Import/Export）等操作
- 一般来讲，MIL与实际的实现语言无关，只关注构件的对外表现协议以及构件之间的通讯关系

**缺点**

- 这些语言处理和描述的软件设计开发层次过于依赖程序设计语言，限制了它们处理和描述比程序设计语言元素更为抽象的高层次软件构架元素的能力

### 3.2.3 基于软构建的描述语言——CDL

**将软件系统描述成一种是由许多以特定形式相互作用的特殊软件实体构造组成的组织或系统**

**特点**

- 以构件为单位来描述软件
- 面向的是底层的程序设计语言

**优点**

- 以描述描述组件的安全特性及其特性
- 能够使用时间运算符（如 next 和 Lead-to）描述进度属性

**缺点**

- 应用范围有局限性，不适合一般的体系结构描述

### 3.2.4 基于体系结构的描述语言——ADL

**是一门用于描述的语言，可以在指定的抽象层次上描述软件体系结构**

**特点**

- 简单易懂
- 有严格的语义和表述符号
- 提供了很多分析工具

**ADL优点**

- 语义精确
- 有良好的整体性
- 有良好的抽象性

**ADL缺点**

- 没有普遍一致的意见：ADL应表现什么，特别是架构的行为
- 目前使用的表现，分析困难且无商业工具支持
- 大多数ADL倾向于垂直优化特定的分析架构的共同概念



<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225144638.png" alt="image-20230129225144638" style="zoom:80%;" />

## 3.3 4+1视图

![image-20230129225234478](https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225234478.png)

**逻辑视图**

- 称设计视图（Design View），包含了类、接口和协作，它们形成了问题及对问题解决方案的术语词汇。这种视图主要支持系统的功能需求，即系统提供给最终用户的服务

- 使用 **类图表示**

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225619363.png" alt="image-20230129225619363" style="zoom:67%;" />

**开发视图**

- 又称为实现视图（Implementation View），包含了用于装配与发布物理系统的构件和文件。这种视图主要对系统发布的配置管理，它由一些独立的构件和文件组成；这些构件和文件可以用各种方法装配，以产生运行系统

- 使用 **构件图表示**

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225913048.png" alt="image-20230129225913048" style="zoom:67%;" />

**物理视图**

- 又称部署视图（Deployment View），包含了形成系统硬件拓扑结构的节点（系统在器上运行）。这种视图主要描述对组成物理系统部件分布、交付和安装

- 使用 **协作图表示**

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129230041985.png" alt="image-20230129230041985" style="zoom:67%;" />

**过程视图**

- 又称为进程视图，包含了形成系统并发与同步机制的线程和进程，该图主要针对性能、可伸缩性和系统的吞吐量

- 使用 **序列图/活动图表示**

  <img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225840501.png" alt="image-20230129225840501" style="zoom:67%;" />

**场景视图**

- 又称用例视图（UseCase View)，由专门描述可被最终用户、分析人员和测试人员看到的系统行为的用况组成。用例视图实际上没有描述软件系统的组织，而是描述了形成系统体系结构的动力

- 使用 **用例图表示**

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129225608461.png" alt="image-20230129225608461" style="zoom:67%;" />

**总结**

- 最终用户关心的是系统的功能，因此会侧重于逻辑视图
- 程序员关心的是系统的配置、装配等问题，因此会侧重于实现(开发)视图
- 系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程(处理)视图
- 系统工程师关心的是系统的发布、安装、拓扑结构等问题，因此会侧重于部署(物理)视图。
- 分析人员和测试人员关心的是系统的行为，因此会侧重于用例(场景)视图

## 3.4 ADLs的核心设计元素

●**组件（Component）**：表示系统中主要的计算元素和数据存储，如客户端、服务器、数据库等；

●**连接件（Connector）**：定义了组件之间的交互关系，如过程调用、消息传递、事件广播等；

●**软件架构配置（Architecture Configuration）**：描述组件、连接件之间的拓扑关系；

●**约束条件（constraint）**：定义组件之间依赖、组件与连接件之间依赖的约束

●通常，ADL还会采用一种形式化技术作为语义信息描述的理论基础

## 3.5 主要的形式化ADL语言及其应用场景

![image-20230129230654560](https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129230654560.png)

# 第四章 软件体系结构的评估

## 4.1 质量属性

1. 可修改性
2. 可用性
3. 性能
4. 可测试性
5. 易用性
6. 安全性
7. 兼容性
8. 可移植性
9. 清晰性
10. 健壮性

## 4.2 评估方法的分类

### 4.2.1 基于场景的

**QAW（质量属性专题研讨会）——SA之前**

**ARID（积极的中间设计审核方法）——SA开发过程中**

**SAAM（软件构架分析方法）——SA之后，适用用于初学者**

**ATAM（体系结构权衡分析方法）——SA之后**

### 4.2.2 基于度量与预测的——更加客观

- 还有一种基于形式化验证方法、数学模型、模拟技术和预测技术的量化分析方法

- 优点：能够提供更为客观和量化的质量评估

- 缺点：基于度量的评估方式必须是在体系结构完成之后，而且评估人员需要对目标系统结构较为熟悉

# 第五章 软件体系结构集成开发环境

## 5.1 集成开发环境的作用（优点）

**使用体系结构集成开发环境研究软件体系结构的优点：**

1. **集成开发环境使开发者摆脱了繁杂的语法，语义，标识符号和公式的困扰，可以集中精力设计系统的结构**
2. **对于规模庞大，结构复杂的软件系统，资源的有效管理和利用极其重要。集成开发环境使用文件系统有效地管理和支配文件和文件夹等资源，用文档支持系统开发和维护，使项目跟踪和控制变成可能，有效地提高了软件生产率，降低了开发和维护成本，保证了软件产品的质量**
3. **集成开发环境把开发过程中所需的各项功能集合在一起，实现了体系结构分析、设计、建模、验证的自动化，这是形式化方法无法取代的。此外，它还提供了友好的图形用户界面和可视化操作，形象化了开发过程和结果**

**集成开发环境的功能**

1. **辅助体系结构建模**
2. **支持层次结构的描述**
3. **提供自动验证机制** 
4. **提供图形和文本操作环境** 
5. **支持多视图**

## 5.2 体系结构IDE原型的组成部分

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230129233310224.png" alt="image-20230129233310224" style="zoom:80%;" />

1. **用户界面层**

   用户界面层是用户和系统交互的唯一渠道，用户需要的操作都被集成到这一层。这些操作可以通过编辑器和视图来实现

2. **模型层**

   模型层是系统的核心层，系统的大部分功能都在这一层定义和实现，它主要的任务是辅助体系结构集成开发环境建立体系结构模型

3. **基础层**

   这一层是系统的基本保障，涵盖了系统运行所需的软硬件支撑环境，它还对系统运行时所用的资源进行管理和调度。通常，普通的简单配置就可以满足系统运行需求，但是有的体系结构集成开发环境需要更多的支持环

## 5.3 主流的体系结构IDE

1. Arch Studio
2. SysADL Studio
3. ACME Studio

# 第六章 软件架构技术债与坏味道

## 6.1 技术债

**技术债：**技术债是指开发人员为了加速软件开发，或是由于自身经验的缺乏，有意或无意地在应该采用最佳方案时进行了妥协，使用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担

**技术破产：**随着软件发生持续变化，总的技术债一直增加，当累积的技术债达到无法偿还的地步，使得不得不放弃该软件产品

**技术债的分类**

- **代码债**：开发时没有守代码规范导致的债务，来源包括静态分析工具的违规行为和不一致的编码风格
- **设计**：在设计时未采用最优解决方案导致的债务，来源包括设计臭味和违背设计规则的行为。架构技术债也是设计债的一种
- **测试债**：测试环节产生的债务，一般由测试的缺乏、测试覆盖面不充分以及不恰当的测试设计导致
- **文档债**：由技术文档问题产生的债务，包括缺少重要技术文档、较差的文档和未及时修改更新的文档

<img src="https://picogo-1314393134.cos.ap-nanjing.myqcloud.com/markdown/image-20230130094924931.png" alt="image-20230130094924931" style="zoom:80%;" />

**产生技术债的根本原因**

- **进度压力**
- **软件设计师缺乏足够的经验与技巧**
- **不注重设计原则的应用**
- **缺乏对设计坏味道的重构意识**
- **开发中有意采用非最优解的选择**

**代码债的表现**

- 不必要的代码重复和复杂性
- 较低的代码可读性的较差的代码风格
- 使得软件解决方案在未来某个时间点更新时易于中断的组织不当的逻辑

**发现技术债**

- 对于代码类型的技术债，在软件开发、管理和运行中往往会出现一些信号，通过这些信号可以及时找出技术债
  - 系统加载时间变长
  - 特定模块缺陷率不断增加
  - 同一问题在不同的模块或者组件中出现、增加新的功能时，新的bug数量持续增加
  - 修复bug的时间变长
  - 某个模块或者组件难以被团队理解或测试
  - 某个模块或组件的源代码被频繁修改

## 6.2 代码坏味道

**面向对象程序中可能出现的代码坏味道有哪些**

- **应用级坏味道**
  - 重复代码
  - 人为复杂性：使用过于复杂的设计模式
  - 散弹式修改：遇到变化，需要做出许多小修改
- **类级坏味道**
- **方法级坏味道**
  - 方法过长：方法含有太多代码行
  - 参数太多
  - 超长标识符
  - 超短标识符
  - 数据过量返回
  - 超长代码行

**典型的设计坏味道**

- **连接件嫉妒**
- **过度分散的功能**
- **模糊接口**
- **无关的相邻连接件**

# 第七章 软件架构脆弱性

## 7.1 软件脆弱性

**软件脆弱性：导致破坏系统安全策略的系统安全规范、系统设计、实现和内部控制等方面的弱点**

**软件脆弱性的特点**

- 脆弱性是软件系统中隐藏的一个弱点，本身不会引起危害，但被利用后会产生严重的安全后果
- 在软件开发过程中，自觉或不自觉引入的逻辑错误是大多数脆弱性的根本来源
- 与具体的系统环境密切相关，系统环境的任何差异都有可能导致不同的脆弱性问题
- 旧的脆弱性得到修补或纠正的同时可能会引入新的脆弱性
- 脆弱性问题会长期存在。

## 7.2 软件架构的脆弱性

**软甲架构脆弱性**

- 软件架构脆弱性属于软件设计脆弱性或软件结构脆弱性的一种。软件架构脆弱性是更高层次的软件结构脆弱性，也是更加重要的软件脆弱性问题
- 软件（系统）架构设计存在一些明显的或者隐含的缺陷，攻击者可以利用这些缺陷攻击系统，或者当受到某个或某些外部刺激时，系统发生性能下降、稳定性下降、可靠性下降、安全性下降等等。如果软件架构具备这类缺陷，我们认为该软件架构是脆弱的，也就是软件架构脆弱性

**特定风格的脆弱性**

**在第二章给出**

# 名词解释

**软件危机**：指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。

**软件重用**：指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。

**CDL**：基于软构件的描述语言，由许多以特定形式相互作用的特殊软件实体构造组成的组织或系统。

**MIL**：模块内联语言，是将一种或多种传统程序设计语言模块连接起来描述软件的体系结构的方法。

**SAAM**：软件架构分析方法，它试图通过场景来测量软件的质量，而不是泛泛的不精确的质量属性描述。

**ATAM**：体系结构权衡分析方法，是一种能够权衡多个相关甚至是不一致的质量需求或者目标的评估方法

**技术债**：技术债是指开发人员为了加速软件开发，或是由于自身经验的缺乏，有意或无意地在应该采用最佳方案时进行了妥协，使用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。

**代码坏味道**：如果程序中的某一段代码是不稳定或者有一些潜在问题的，那么该段代码往往会包含一些明显的不太好的痕迹。

**技术破产**：随着软件发生持续变化，总的技术债一直增加，当累积的技术债达到无法偿还的地步，使得不得不放弃该软件产品。

**软件脆弱性**：导致破坏系统安全策略的系统安全规范、系统设计、实现和内部控制等方面的弱点
