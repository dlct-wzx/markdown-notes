# 操作系统

[TOC]

## 第一章 操作系统引论

### 1.1 操作系统的目标与作用

![image-20220301204325966](https://i0.hdslb.com/bfs/album/8174d2008c5d6d610beb8a0c62be4fe12bd572b4.png)

**操作系统的组成**

- 硬件系统（裸机）：CPU、存储器（主存、辅存）、输入/输出设备等
- 软件系统：系统软件、应用软件
- 系统软件：管理计算机本身的操作。如操作系统、编译…   
- 应用软件：提供给用户进行解题。如科学计算、事物管理…

**计算机系统的层次结构**

![image-20220301204831542](https://i0.hdslb.com/bfs/album/22590ce4b0804903124972a3e9c70ca13a2d9a5f.png)

- 计算机系统由硬件和软件组成 
- 操作系统是在硬件基础上的第一层软件 
- 操作系统是其他软件和硬件之间的接口 

**操作系统的定义**

 操作系统是计算机系统中的一个**系统软件**，是一些程序模块的集合。使得用户能够**灵活、方便、有效**地使用计算机，使整个计算机系统能高效地运行，从而在计算机与用户之间起到**接口**的作用。  

**操作系统的目标**

- 方便性
- 有效性
- 可扩充性
- 开放性

**操作系统的作用**

- **OS作为用户与计算机硬件系统之间的接口**

  提供功能

  - 命令接口
    - 联机命令接口
    - 脱机命令接口
  - 程序接口
  - GUI（图形用户界面）

  目标：方便用户使用

  ![image-20220301210529405](https://i0.hdslb.com/bfs/album/096de00fd8d644cd277cc17d1a5706aebff1ff68.png)

- **OS作为计算机系统资源的管理者**

  **提供的功能**

  - 处理机管理
  - 存储器管理
  - I/O设备管理
  - 文件管理

  目标：高效、安全

- **OS用作扩充机器**



![image-20220306125744139](https://i0.hdslb.com/bfs/album/e297fb4a9d3e962bd01ecc669708d5063c489b94.png)

### 1.2 操作系统的发展

- **人工操作方式**

  **主要缺点**：用户独占全机、人机速度矛盾导致资源利用率极低

- **单道批处理系统**

  引入 **脱机输入/输出技术**（用磁带机完成），并 **监督程序负责**（操作系统的雏形） 负责控制作业的输入与输出

  **主要优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升

  **主要缺点**：系统中的资源得不到充分的利用。在**内存中仅有一道程序**，只有该程序运行结束之后才能调用下一道程序。**CPU由大量时间是在空闲等待I/O完成**

  ![image-20220301212104513](https://i0.hdslb.com/bfs/album/16879a73be50f679e87baadb9d6850ac9d44c1a2.png)

- ##### 多道批处理系统

  每次往内存中输入多道程序，操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行

  **主要优点：**多道程序 **并发** 执行，**共享** 计算机资源。**资源利用率大幅提升**，CPU和其他资源保持“忙碌”状态，系统吞吐量增大

  **主要缺点：**用户响应时间长，**没有人机交互功能**

- **分时操作系统**

  计算机以 **时间片** 为单位 **轮流为各个用户/作业服务**，各用户可以通过终端与计算计进行交互

  **主要优点：**用户请求可以解释被相应，**解决了人机交互问题**。允许多个用户同时使用一台计算机

  **主要缺点**：**不能优先处理一些紧急任务**

- **实时系统**

  实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，**在规定的时间内完成对该事件的处理**，并控制所有实时任务协调一致地运行。实时操作系统的主要特点是 **及时性和可靠性**

- **实时系统与分时系统的比较**

  ![image-20220302211655131](https://i0.hdslb.com/bfs/album/8ac89dfc7a25e4a5cde2609a1a6bc2281cdf717c.png)

![image-20220306135445037](https://i0.hdslb.com/bfs/album/4a271f6b79d7e33baf13caab7e65f0adde42fb92.png)

### 1.3 操作系统的基本特性

1. **并发性（Concurrence）**

   - **并行性**是指两个或多个事件在同一时刻发生
   - **并发性**是指两个或多个事件在同一时间间隔内发生（**宏观上同时，微观上交替**）
   - **进程**是指在系统中能独立运行并作为资源分配的基本单位

2. **共享性（Sharing）**

   **共享**是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用

   - **互斥共享方式**（一个时间段内只允许一个进程访问该资源）
   - **同时共享方式**（允许一个时间段内由多个进程“同时”访问该资源）

3. **虚拟性（Virtual）**

   操作系统中的所谓**虚拟**，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物

   eg：空分复用技术，时分复用技术

4. **异步性（Asynchronism）**

   进程是以人们不可预知的速度向前推进，此即进程的**异步性**

**注：**

1. 如果失去并发性，则系统只有一个层序正在运行，则共享性失去意义
2. 如果失去共享性，则两个程序就不能同时访问硬盘资源，就无法同时发送文件，也就无法并发
3. 只有系统拥有并发性，才有可能导致异步性

![image-20220306132003819](https://i0.hdslb.com/bfs/album/b019858838297b843d19b3242c04c399a45f5af3.png)

### 1.4 操作系统的主要功能

1. **处理机管理功能**
   1. **进程控制**：进程控制的主要功能是创建进程、撤销已结束的进程，以及控制进程在运行过程中的状态转换
   2. **进程同步**：为使多个进程能有条不紊地运行，系统中必须设置相应的进程同步机制。进程互斥方式、进程同步方式
   3. **进程通信**
   4. **调度**
2. **存储器管理功能**
   1. **内存分配**
      -  为每道程序分配内存空间，使它们“各得其所“
      - 提高存储器的利用率，尽量减少不可用的内存空，允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。OS一般采用静态和动态两种分配方式
   2. **内存保护**
   3. **地址映射**
   4. **内存扩充**


## 第二章 进程的描述与控制
### 2.1 前驱图和程序执行

**前驱图**

- 用于描述一个 **程序** 的各部分见的依赖关系，或者一个大的 **计算** 的各个子任务间的因果关系

- 前驱图不允许有循环
- eg：![image-20220312172227862](https://i0.hdslb.com/bfs/album/f5c8cdd037ad0a7d5bd01398aafb1ca9f353a691.png)

**程序顺序执行**

- 仅当前一操作执行后，才能执行后继操作
- 特点：
  - **顺序性**：一个程序的各个部分的执行，严格地按照某种先后次序执行
  - **封闭性**：程序运行时独占全部系统资源
  - **可再现性**：

**程序并发执行**

- 对一批程序进行处理时，可以并发执行
- 特征：
  - **间断性**：程序内部资源相互制约，导致并发程序具有 **执行-暂停-执行**
  - **失去封闭性**：多个程序共享系统中的各种资源
  - **不可再现性**

### 2.2 进程的描述
**进程、进程实体的定义**

- **程序：**一个指令序列

- 为了方便操作系统管理，完成程序的并发执行，引入了 **进程、进程实体** 的概念
- 系统为每个运行程序配置一个数据结构，称为 **进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放的位置）
- **进程实体（进程映像，简称为“进程”）**静态
  - **PCB**、**程序段**，**数据段** 三部分所构成
  - **创建进程** 就是进程实体中的PCB，**撤销进程** 就是撤销进程实体中的PCB
  - **PCB时进程存在的唯一标志**
- **进程的定义 ** 动态
  - **进程**是程序的**一次执行**，该程序可以与其它程序**并发执行**
  - **进程**是进程实体的 **运行过程**，是系统进行 **资源分配** 和 **调度** 一个独立单位

**进程与程序的区别**

- 程序是静态文本，进程是动态过程 

- 一个进程可以执行一个或多个程序，几个进程可以同时执行一个程序
- 程序可作为软件资源长期保存，进程只是一次执行过程，是暂时的，不能长期保存
- 进程是系统分配调度的独立单位，能与其他进程并发执行 

**进程的组成**

- **进程（进程实体）有PCB、程序段、数据段组成**
- 讨论进程 **内部的构成**

<img src="https://i0.hdslb.com/bfs/album/6747b68354af72301e5448161ff8b90a4725783e.png" alt="image-20220312175828498" style="zoom:80%;" />

**进程的组织**

- 讨论 **多个进程之间** 的组织方式问题

- **链接方式**

  <img src="https://i0.hdslb.com/bfs/album/6f40828643a94b4b41c64ecf2369a7282366a1d8.png" alt="image-20220312180304348" style="zoom:80%;" />

- **索引方式**

  <img src="https://i0.hdslb.com/bfs/album/e3a0720e66a60ccccedc700b5f0741394f46fccf.png" alt="image-20220312180348450" style="zoom:80%;" />

<img src="https://i0.hdslb.com/bfs/album/7b279c258df5e0556a6792bb31776f8751d44a00.png" alt="image-20220312180106140" style="zoom:67%;" />

**进程的特征**

<img src="https://i0.hdslb.com/bfs/album/1a756793bb9df5882ef69344d4cda7ab2fadae73.png" alt="image-20220312180642566" style="zoom:80%;" />

**总结**

<img src="https://i0.hdslb.com/bfs/album/ad40f8031dc8b4e81c96a8ccc8da72e69745b311.png" alt="image-20220312180851861" style="zoom:80%;" />



### 2.3 进程的状态与转换

**进程的三种基本状态**

- **就绪状态**：拥有除了处理机（CPU）之外的所有资源
- **执行状态**：就绪状态拥有处理机（CPU）
- **阻塞状态**：因等待某一事件而暂停不能运行

**创建状态与终止状态**

- **创建状态**
  就绪状态之前的总和：进程正在被创建，操作系统为进程分配资源、初始化PCB
- **终止状态**
  进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

**挂起状态：**暂时调到**外存**等待的进程状态

**进程状态的转换**

**五状态**

![image-20220314102355716](https://i0.hdslb.com/bfs/album/ddb7617dbfbed2ca9da89aa7c5fd4c99f1f70696.png)

**七状态**

![image-20220412215737075](https://i0.hdslb.com/bfs/album/66c339c2c1c2e0abdd520b8b2662d880a6f1562e.png)

**总结**

![image-20220314102424142](https://i0.hdslb.com/bfs/album/ceb9ac8428d6398f09f0dcb44a8c21b7cc5771c7.png)

### 2.4 进程控制

**进程控制** 的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能（**反正进程控制就是要实现进程状态转换**）

![image-20220314103452546](https://i0.hdslb.com/bfs/album/94ff80337fa3566e7365586874935bf08ab69dc1.png)

- 用 **原语** 实现进程控制。原语的特点是执行期间 **不允许中断**，只能一气呵成。这种不可被中断的操作即 **原子操作**

- 原语采用 **关中断指令** 和 **开中断指令** 实现

  <img src="https://i0.hdslb.com/bfs/album/5e108bb5fdc42f35f44344637612a73abb8f0ec6.png" alt="image-20220314104802218" style="zoom:67%;" />

三类**原语**

- 更新PCB信息
- 将PCB插入合适的队列
- 分配/回收资源

**进程的创建**

![image-20220314105544150](https://i0.hdslb.com/bfs/album/4a2ac6266645b7a99ad78b18686030a54672a1de.png)

**进程的终止**

![image-20220314105753300](https://i0.hdslb.com/bfs/album/d153d723354fdd555e97f878f16e59fa0cebc43f.png)

**进程的阻塞和唤醒**

![image-20220314105920442](https://i0.hdslb.com/bfs/album/1787a7bc520a0e01ef37b1f690ba162da28dc65d.png)

**进程的切换**

![image-20220314110043835](https://i0.hdslb.com/bfs/album/36058f4333e6f7254f9f407e9059186a1c342164.png)

**总结**

![image-20220314110147657](https://i0.hdslb.com/bfs/album/c5d9f8becca283df4f0d0ab2505dc5ed3e72facd.png)

### 2.5 进程同步与进程互斥

- 在多道系统中，由于资源共享或进程合作，使进程间形成 **间接相互制约** 和 **直接制约关系**，这是需要用 **进程互斥与同步机制** 来协调两种制约关系

- 为什么要有进程同步：**进程的异步性**

- **同步** 亦称 **直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上 **协调** 它们的 **工作次序** 而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

- **互斥** 亦称 **间接制约关系**，它是指当一个进程访问某临界资源时，另一想要访问该临界资源的进程必须等待。

**临界资源**

- 定义：**一个时间段内只允许一个进程使用**的资源。许多物理设备（如摄像头、打印机），许多变量、数据、内存缓冲区等都属于临界资源。

- 对于临界资源的访问必须 **互斥** 的进行

- 为实现对 **临界资源** 的互斥访问，因保证诸进程互斥地进入自己的 **临界区**。把每个进程中访问临界资源的那段代码称为 **临界区**。为此，每个程序在进入其 **临界区** 前，必须先申请，经允许后方能进入

- 对 **临界资源** 进程 **互斥访问** 的原则：

<img src="https://i0.hdslb.com/bfs/album/99625234d10cf723855e3c9f0d2c6bba800eb040.png" alt="image-20220319152907607" style="zoom:67%;" />



**总结**

<img src="https://i0.hdslb.com/bfs/album/89cd6cf46aa0d1b715add24207aee54825d7905d.png" alt="image-20220319153010289" style="zoom:80%;" />

### 2.6 进程互斥的硬件实现方法

**中断屏蔽方法**

- 利用 **开/关中断指令** 实现

- 优点：简单、高效
- 缺点
  1. 滥用关中断权力可能导致严重后果
  2. 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力
  3. **不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程**

<img src="https://i0.hdslb.com/bfs/album/4d8fce51209733381e21051b798845e4fc8d74ae.png" alt="image-20220319153307014" style="zoom: 67%;" />

**Test-and-Set指令**

简称 **TS指令或TSL指令**

- TSL指令 **是用硬件实现的**，执行过程不允许被中断，只能一气呵成。以下是c语言描述逻辑

```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true 表示已加锁，false表示未加锁
bool TestAndSet(bool *lock)
{
    bool old;
    old = *lock;	//old用来存放lock原来的值
    *lock = true;	//无论之前是否已加锁，都将lock设为true
    return old;		//返回lock原来的值
}

//以下是使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));	//上锁并检查
临界区代码段...
lock = false;	//解锁
剩余区代码段...
```



**Swap指令**

- 有的地方也叫Exchange指令，或简称XCHG指令
- Swap指令 **使用硬件实现的**，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑

```c
//Swap指令的作用是交换两个变量的值
void Swap(bool *a, bool *b)
{
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

//以下是用Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while(old == true)
    Swap(&lock, &old)；
临界区代码...
lock = false;
剩余区代码...
```



逻辑上来看**Swap**和**TSL**上并无太大差别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old，若old为flase则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区



**Swap**和**TSL**

- 优点：实现简单；适用于多处理机环境
- 不满足 **让权等待** 原则



**总结**

![image-20220319160209180](https://i0.hdslb.com/bfs/album/f7bc9070f887f3c3e803c403c49f966691d809fd.png)



### 2.7 信号量机制

- 之前的所有方法 **无法实现“让权等待”**
- 用户进程可以通过使用操作系统提供的 **一对原语(执行只能一气呵成)** 来对 **信号量** 进行操作，从而方便的实现进程互斥、进程同步
- **信号量** 就是一个变量，可以用一个信号量来 **表示系统中某种资源的数量**

- **一对原语**：**wait(S)** 原语和 **signal(S)** 原语，可以吧原语理解为函数，函数名为wait和signal,括号里的 **信号量S** 其实是参数

- wait、signal原语常 **简称为P、V操作**

 

**整形信号量**

- 用一个 **整数型的变量** 作为信号量，用来 **表示系统中某种资源的数量** 
- 对信号量的操作只有三种：**初始化、P操作、V操作**
- **检查** 和 **上锁** 一气呵成，避免了并发、异步导致的问题
- 存在问题：不满足 **让权等待** 原则，会发生 **忙等**

```c
int S = 1;	//初始化整形信号量，表示资源数

void wait(int S){	//wait原语（P操作），相当于请求分配资源
    while(S <= 0) ;
    S=S-1;
}

void signal(int S){	//signal原语（V操作），相当于释放单位资源
    S=S+1;
}

eg：
进程P0:
...
wait(S);	//进入区，申请资源
使用资源	 //临界区，访问资源
signal(S);	//退出区，释放资源
...
```



**记录型信号量**

- 为解决 **整型信号量忙等** 的问题，人们提出了 **记录型信号量**
- **申请资源时**： 如果剩余资源数不够，使用**block原语**使进程从运行态进入阻塞态，并把挂到信号量S的**等待队列（阻塞队列）**中
- **释放资源后：**若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程**从阻塞态变为就绪态**

```c
//记录型信号量的定义
typedef struct{
    int value;			//剩余资源数
    struct process *L;	//等待队列
}semaphore;

//某进程需要使用资源时，通过wait原语申请
void wait(semaphore S){
    S.value--;
    if(S.value < 0){
        block(S.L);
    }
}

//进程使用完资源后，通过signal原语释放
void signal(semaphore S){
    s.value++;
    if(S.value<=0){
        wakeup(S.L);
    }
}
```

**AND型信号量**

**信号量集**

**总结**

<img src="https://i0.hdslb.com/bfs/album/27ba0dc8e2fc425b4e5e933eaa9d3f93dded25ef.png" alt="image-20220319182254741" style="zoom: 80%;" />

### 2.8 用信号量实现进程互斥、同步、前驱关系

**互斥实现**

1. 发现进程关键活动，划定临界区
2. 设置 **互斥信号量** mutex, **初值为1**

3. 在临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

- 注：**P、V操作必须成对出现**

**同步实现**

- **使本来异步并发的程序，有序运行**

1. 分析什么地方需要实现 **同步关系**，集必须保证一前一后执行的两个操作
2. 设置 **同步信号量S，初始为0**
3. **在前操作之后执行V(S)**
4. **在后操作之前执行P(S)**



**前驱关系**

<img src="https://i0.hdslb.com/bfs/album/e306e8fc431a229049522244e29eedb617da0c80.png" alt="image-20220319220548441" style="zoom:67%;" />

使程序按以上顺序执行

1. **为每一都前驱关系各设置一个同步变量**
2. **在前操作之后对相应的同步变量执行V操作**
3. **在后操作之前对相应的同步变量执行P操作**

**总结**

![image-20220319221140585](https://i0.hdslb.com/bfs/album/042cdaa4e8489227a9d8500741c0394197c11d6e.png)

### 2.9 生产者-消费者问题

**问题描述**：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（这里的产品，可以理解为某种数据）。

- 生产者、消费者共享一个初**始为空、大小为n的缓冲区**
- 只有**缓冲区没满**时，生产者才能包产品放入缓冲区，否则必须等待（**同步**）
- 只有**缓冲区不空**时，消费者才能从中取出产品，否则必须等待（**同步**）
- 缓冲区是临界资源，各进程必须 **互斥的访问**

```c
semaphore mutex = 1;	//互斥信号量
semahpore empty = n;	//同步信号量，表示空闲缓冲区个数
semahpore full = 0;		//同步信号量，表示产品数量

profucer(){
    while(1){
        生产一个产品;
        P(empty);	//消耗一个空闲缓冲区
        P(mutex);
        把产品放入缓冲区;
        V(mutex);
        V(full);	//增加一个产品
    }
}

consumer(){
    while(1){
        P(full);	//消耗一个产品
        P(mutex);
        从缓冲区取出一个产品;
        V(mutex);
        V(empty);
        使用产品;
    }
}
```

![image-20220321103316253](https://i0.hdslb.com/bfs/album/1d483405badc993ac96db1877878d65b2f114f2e.png)







### 2.10 进程通信

- **进程通信就是指进程之间的信息交换**

- 为了保证安全，**一个进程不能直接访问另一个进程的地址空间**

- 但是进程之间的信息交换又是必须的，为了保证进程间的安全通信，操作系统提供了一些方法：**共享存储、消息传递、管道通讯**

**共享存储：**

- 两个进程对共享空间的 **访问** 必须是 **互斥的**
- **基于数据结构的共享**：比如共享空间里只能放一个长度为10的数组。这种共享凡是速度慢、限制多，是一种 **低级通信** 方式
- **基于存储器的共享**：在内存中画出一块共享存储区，数据的形式、存放的位置都有进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种 **高级通信** 方式

**管道通信**

![image-20220321110226838](https://i0.hdslb.com/bfs/album/57acdd25c7809700a3e80f2170c7823de2e0f787.png)

- 管道只能采用 **半双工通信**，某一段时间内只能实现单向的传输。如果要实现 **双向同时通信**，则 **需要设置两个管道**
- 各进程要 **互斥** 的访问管道
- 数据以字符流的形式写入管道，当 **管道写满** 时，**写进程**的write()系统调用将被 **阻塞**，等待读进程将数据取走。当读进程将数据全部去走后，**管道变空**，此时 **读进程**的read()系统调用将被 **阻塞**
- **如果没写满，就不允许读。如果没读空，就不允许写**
- 数据一点被读出，就从管道中被抛弃

**消息传递**

- 进程间的数据交换以 **格式化的消息(Message)**为单位。进程通过操作系统提供的”发送消息/接收消息“了两个 **原语** 进行数据交换

<img src="https://i0.hdslb.com/bfs/album/9d0e8e7a06582ac5c784c50d0909291f54817a84.png" alt="image-20220321111136888" style="zoom:80%;" />

**总结**

![image-20220321111307701](https://i0.hdslb.com/bfs/album/c7db512a61aa6e404fe4401acdba7e374cd0574c.png)

### 2.11 线程概念 多线程模型

**什么是线程**

- 可以将线程理解为”轻量级进程“，作为 **调度和分配的基本单位**
- **线程是一个基本的CPU执行单元，也是程序执行流的最小单位**
- **进程内的各线程之间也可以并发，从而进一步提升了系统的并发度**
- **引入线程后，进程只作为除CPU之外的系统资源分配单元**

<img src="https://i0.hdslb.com/bfs/album/1834e080f28fd491538a3094aac4fae71a0e5374.png" alt="image-20220321120032741" style="zoom:80%;" />

**线程的属性**

<img src="https://i0.hdslb.com/bfs/album/f4833b90c68ea49c689ab945dd151d94c2032a22.png" alt="image-20220321120244533" style="zoom:80%;" />

**线程的实现方式**

- **用户级线程（ULT）**
  - **用户级线程**由应用程序通过线程库实现
  - 所有的 **线程管理工作** 都由 **应用程序负责**（包括选曾切换）
  - 用户级线程中，**线程切换**可以在 **用户态下即可完成**，无需操作系统干预
  - 用户级线程对用户来说不透明，对操作系统透明（操作系统只能看见相应的线程）
  - **用户级线程就是从用户视角可以看到的线程**
  - **优点：**
    - 线程切换不需要转换到内核空间
    - 调度算法可以是进程专用的
    - 用户级线程的实现与OS平台无关
  - **缺点：**当一个用户级线程被阻塞后，整个进程会被阻塞，并发度不高。多个线程不能在多核处理器上并发执行

![image-20220412200057197](https://i0.hdslb.com/bfs/album/6234e96e429f9fc56af8464fc2878d1fa84bac07.png)

- **内核级线程（KLT）**
  - 内核级 **线程的管理工作由操作系统内核** 完成。**内核级线程的切换**必须在 **核心态** 下完成
  - **操作系统可以看到内核级线程**
  - **优点：**
    - 在多处理器系统中，内核能够同时调度同一进程中的多**个线程并行执行**
    - 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程
    - 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，**切换开销小**
    - 内核本身也可以采用多线程技术，可以**提高系统的执行速度和效率**

![image-20220412200330480](https://i0.hdslb.com/bfs/album/87b9e48ce972e2eec4d1fad3788305616c5bd236.png)

- **组合方式**
  - 将n个用户级线程映射到m个内核级线程上(n>=m)
  - **优点：**克服了并发度不高，占用资源大的缺点

![image-20220412201217326](https://i0.hdslb.com/bfs/album/9baefb660ae8a5ef53668d65dea97f7f5db39ca1.png)

- **重点：内核级线程才是处理机分配的单位**

  

**总结**

![image-20220412202152685](https://i0.hdslb.com/bfs/album/379c54c3943cb569535af400e41fafec58118558.png)

## 第三章 处理机调度与死锁

### 3.1 处理机调度的层次和调度算法的目标

**调度的基本概念:** **调度** 的实质是一种资源分配，**处理机调度** 是对处理机资源进行分配。**处理机调度算法**是指根据处理机分配策略所规定的处理机分配算法

**调度的三个层次**

- **高级调度（作业调度）**

  由于内存空间优先，因此就需要确定某种规则界定将**作业调入内存的顺序**

- **中级调度（内存调度）**

  引入**虚拟存储技术**之后，可以将暂时不能运行的进程调至外存等待。**中级调度**就是决定 **把那些暂时不能运行的进程，调至外存等待（挂起状态，PCB不会调入外存）**。主要目的是**提高内存利用率和系统吞吐量**

- **低级调度（进程调度）**

  按照某种方法和策略从就绪队列中选取一个进程，交给处理机

- **三层调度的联系、对比**

![image-20220412220016012](https://i0.hdslb.com/bfs/album/b7c88a9f6e2642882035d9530aa9d73d8b30b0ab.png)

**处理机调度算法的目标**

- **共同目标**

  - 资源利用率
  - 公平性

  - 平衡性
  - 策略强制执行
- **批处理系统的目标**
  - 平均周转时间短 
  - 系统吞吐量高
  - 处理机利用率高
- **分时系统的目标**
  - 响应时间快
  - 均衡性
- **实时系统的目标**
  - 截止时间的保证
  - 可预测性

**调度算法的评价指标**

![image-20220416132346844](https://i0.hdslb.com/bfs/album/f463bdb17c9379e0fce189d2b2db3d67638e07ab.png)

### 3.2 作业和作业调度

**作业（Job）：**不仅包含程序和数据，而且还应有作业说明书。系统根据说明书对程序的运行进行控制。是以作业为基本单位从外存调入内存的

**作业步(Job Step)：**在作业运行期间，每个作业都必须经过若干个相对独立又相互关联的顺序加工步骤才能得到结果，其中的每个加工步骤称为一个作业步

**作业控制块（JCB）：**是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息

**作业运行的三个阶段和三种状态：** 

- 收容阶段	后备状态
- 运行阶段	运行状态
- 完成阶段	完成状态

**作业调度的主要任务：**在每次执行作业调度是，做出以下两个决定

- 接纳多少个作业
- 接纳那些作业

**先来先服务（FCFS）**

- 该算法是**最简单的调度算法**，既适用于**作业调度**，也适用于**进程调度**

  ![image-20220416114210859](https://i0.hdslb.com/bfs/album/82f65429d341cd729bc2cf6dd53ed11acee4c661.png)

- eg：

![image-20220415214740301](https://i0.hdslb.com/bfs/album/c9f6283a9cf45def89b98a832f75a9d7191f6b16.png)



**短作业优先（SJ(P)F）**

- 该算法是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度

![image-20220416114143421](https://i0.hdslb.com/bfs/album/e9ecdadc3c931b5021665b782689689b730093a1.png)

- eg：

![image-20220416112031890](https://i0.hdslb.com/bfs/album/8520deca7242deb508fdbfc15db5743753e5c806.png)



**高响应比优先（HRRN）**

![image-20220416115510681](https://i0.hdslb.com/bfs/album/4a1a14e84327f6570919fbe55562b42936b8aaf5.png)

- eg：

![image-20220416115257776](https://i0.hdslb.com/bfs/album/1a906b9c7e53097ed1154618a02c3932cdaa6b7f.png)



**三种算法对比**

![image-20220416120053194](https://i0.hdslb.com/bfs/album/06038c575986cec22fab9749815f858c23f61519.png)

三种算法适用于 **早期批处理系统**



### 3.3 进程调度

**不能进行**进程调度与切换的情况：

- **处理中断的过程中**
- 进程在 **操作系统内核程序临界区中**
- 在 **原子操作过程中**

**进程调度的任务**

- 保存处理机的现场信息
- 按某种算法选取进程
- 把处理器分配给进程

**进程调度的机制**

​	为实现进程调度，在进程调度机制中，应具有如下三个基本部分，如下图所示

- 排队器
- 分排器
- 上下文切换器

![image-20220416124238270](https://i0.hdslb.com/bfs/album/feba90d1543fb3bb79f164962b054c1652a12db5.png)

**进程调度的方式**

- **非抢占式（非剥夺调度方式）：**只允许进程主动放弃处理机。**实现简单**，适用于早期的 **批处理系统**
- **抢占方式（剥夺调度方式）：**这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。**可以优先处理更紧急的进程**，适用于 **分时操作系统，实时操作系统**



**时间片轮转算法（RR）**

![image-20220416171933364](https://i0.hdslb.com/bfs/album/8cce87b194fda551666f1d9d3ccc8345ec99e906.png)

- **时间片的选择**
  - 时间片太大算法会退化为 **先来先服务算法**
  - 时间片太小进程切换过于频繁

- eg：

![image-20220416170707338](https://i0.hdslb.com/bfs/album/a3cf1fe79ade35cd888682eec35199b17fe6ef78.png)

![image-20220416170534459](https://i0.hdslb.com/bfs/album/89d7db871ecc86cf7dfff01dc4dbc3d4d8e2aa9d.png)

![image-20220416170737553](https://i0.hdslb.com/bfs/album/8cdf1d4d01d7ad9d39010307b094916cb6bf4843.png)



**优先级调度算法**

![image-20220416173114719](https://i0.hdslb.com/bfs/album/52e7256936658c6f89c2fdd071255f494c5387ca.png)

eg：

- 非抢占式

![image-20220416172216106](https://i0.hdslb.com/bfs/album/2526d15bd29cf64e5e2a65cf665cf174607a9795.png)

- 抢占式

![image-20220416172405862](https://i0.hdslb.com/bfs/album/a43808f229bcda9e9e9b26ed89010fad30b9de4e.png)



**多级反馈队列调度算法**

![image-20220416173820473](https://i0.hdslb.com/bfs/album/c6db4351c9b17324de2d55dc4f1a31b72d529a96.png)

- eg：

![image-20220416173611680](https://i0.hdslb.com/bfs/album/93ece3d750c70fc4cd4da450e488101887de5e0e.png)



**三种算法对比**

![image-20220416173843563](https://i0.hdslb.com/bfs/album/204334e68907b3a9b85405288e85f5425f8d2693.png)

- 这三种算法适用于 **交互式系统**



### 3.4 实时调度

在实时系统中，可能存在着两类不同性质的实时任务，即**HRT（Hard Real-time，硬实时）任务**和**SRT（Soft Real-time，软实时）任务**。实时调度必须能满足实时任务对截止时间的要求

**实现实时调度的基本条件**

- 提供必要的信息
  - 就绪时间
  - 开始截止时间和完成截止时间
  - 处理时间
  - 资源要求
  - 优先级
- 系统处理能力强
- 采用抢占式调度机制
- 具有快速切换机制

**实时调度算法的分类**

- 非抢占式调度算法
  - 非抢占式轮转调度算法
  - 非抢占式优先调度算法
- 抢占式调度算法
  - 基于时钟中断的抢占式优先权调度算法
  - 立即抢占(Immediate Preemption)的优先权调度算法
  - 

**常用的几种实时调度算法**

- 最早截止时间优先即EDF(Earliest Deadline First)算法 
- 最低松弛度优先即LLF(Least Laxity First)算法 



### 3.5 死锁的概念

![image-20220417171513832](https://i0.hdslb.com/bfs/album/36b566e1b3309200f728856a7c453bb672e17f87.png)

**死锁、饥饿、死循环的异同**

![image-20220417170121974](https://i0.hdslb.com/bfs/album/291f6591575a860074871dae45f3be7b81c4f209.png)



### 3.6 死锁的处理策略-预防死锁

![image-20220417171626531](https://i0.hdslb.com/bfs/album/252ce2d65489b4a2f2d6387cd42de26ef0e49c50.png)

### 3.7 死锁的处理避免死锁

**安全状态**

安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …, Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态

**银行家算法**

- **数据结构**
  - 可利用资源向量 **Available**
  - 最大需求矩阵 **Max**
  - 分配矩阵 **Allocation**
  - 需求矩阵 **Need**

- 详情

  - 当进程$p_i$发出资源请求后，进行检查：
    - 若Request<=Reed[i]，进行第二步
    - Request<=Acailable

  - 系统进行资源预分配

    - Available = Avaiable - Request
    - Allocation[i] = Allocation[i] + Request
    - Need[i] = Need[i] - Request

  - 执行安全性算法

    是否可以找到一个安全序列

### 3.8 死锁的检测与解除

**数据结构：资源分配图**

- 使用**圆形**表示进程
- 使用**矩形**表示资源
- **矩形中的小圆**表示资源的数量
- eg：![image-20220424212203442](https://i0.hdslb.com/bfs/album/71bfd840aaaf158f4fd9c4b26d96cd455f18e143.png)

![image-20220424211532454](https://i0.hdslb.com/bfs/album/f73c9a6612935fc0b7bcc981fe7799a822ea8813.png)



## 第四章 存储器管理

### 4.1 存储器的层次结构

**存储器的多次结构**

![image-20220424213751455](https://i0.hdslb.com/bfs/album/c4b74bae3e6022e214fb212f794380ec5b3d88b6.png)

- **寄存器：**与CPU协调工作，**用于加速存储器的访问速度**，如用寄存器存放操作数，或用作**地址寄存器加快地址转换速度**等
- **高速缓存：**根据程序执行的**局部性原理**将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度
- **主存储器：内存，保存进程运行时的程序和数据**。CPU与外围设备交换的信息一般也依托于主存储器地址空间。**为缓和主存储器的访问速度远低于CPU执行指令的速度，在计算机系统中引入了寄存器和高速缓存**。
- **磁盘缓存：**将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可**减少访问磁盘的次数**。它依托于固定磁盘，提供对主存储器存储空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读/写入的信息

### 4.2 程序的装入和链接

![image-20220424214854064](https://i0.hdslb.com/bfs/album/1193a6c23ce2cc64f32591e223a27798dc9b80ee.png)

![image-20220424215639505](https://i0.hdslb.com/bfs/album/d753be27bbdb7700264ef337997ddc63402b6806.png)

**装入时动态链接方式有以下优点**：

- **便于修改和更新**
- **便于实现对目标模块的共享**



### 4.3 内存管理的概念

![image-20220424222108045](https://i0.hdslb.com/bfs/album/99942d65032dc58797b34fd6418fa8ae6f9a5387.png)



### 4.4 覆盖与交换

为了实现 **内存空间扩充**

**覆盖技术：**

- 将内存分为 **固定区** 和 **覆盖区**
- 常驻内存的程序段放入 **固定区，放入后不再调出**
- 不常用的段放在 **覆盖区，需要使再调入内存，用不到时调出内存**
- **对用户不透明**，增加了编程难度

eg：![image-20220424222729524](https://i0.hdslb.com/bfs/album/5bc2e637ef1aba0ff40bd227b79fc6ebdd471ab1.png)

![image-20220424225806110](https://i0.hdslb.com/bfs/album/65e0ae499f2053e5631c7b8db47509b2fdc6673d.png)

 

### 4.5 连续分配管理方式

**连续分配：**用户进程分配的必须是一个 **连续的内存空间**

**单一连续分配：**

- 内存被分为 **系统区** 和 **用户区**
- 内存中 **只能有一道用户进程**

<img src="https://i0.hdslb.com/bfs/album/60d62e5cdcbdb76b6be2c903a54a3a55da3c4d26.png" alt="image-20220425214828296" style="zoom:50%;" />

**固定分区分配：**

- 建立 **分区说明表**
- <img src="https://i0.hdslb.com/bfs/album/9127ebbd40f124af01b5ef3c6c5b28c007025beb.png" alt="image-20220425215042060" style="zoom: 50%;" />

<img src="https://i0.hdslb.com/bfs/album/3e46b8a21a3d5496576461fd8ca4db81db48c90a.png" alt="image-20220425214807180" style="zoom: 50%;" />

**动态分区分配**

- 数据结构

  - 空闲分区表

    ![image-20220425220349962](https://i0.hdslb.com/bfs/album/9a9378488507ed26f139e8482011ede33980f26f.png)

  - 空闲分区链

    ![image-20220425220402705](https://i0.hdslb.com/bfs/album/8da5e668ce2b4ce1fbd849d0c0e8363cceed06e8.png)

![image-20220425214142865](https://i0.hdslb.com/bfs/album/1f4b1079b8e45bcf151f8c71eb74a6255e681a7a.png)

### 4.6 动态分区分配算法

![image-20220425222417102](https://i0.hdslb.com/bfs/album/1d8708d38fca94d1d108d7bc4b57b36fb15493d9.png)

### 4.7 可重定位分区分配

**紧凑**

- 为了消除外零头，进一步提高主存的利用率，定时地（或者在主存空间紧张时）把主存中的作业“搬家”集中在主存的一端。另一端就产生了一个大的空闲区。这种技术称为存储器的 **紧凑**
- **优点： 解决了可变分区分配所引入的“外零头”问题，解决了可变分区分配所引入的“外零头”问题**
- **缺点：提高硬件成本，紧凑时花费CPU时间**

![image-20220430111356833](https://i0.hdslb.com/bfs/album/a5c40e1fd16644bda38d70cfa15575c939592b83.png)

**动态重定位**

- 系统中增加一个**重定位寄存器**，用它来装入程序在内存中的**起始地址**，程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成。地址变换过程是在程序执行期间，随着对每条指令和数据的访问而自动进行的，故称为**动态重定位**

![image-20220430111900346](https://i0.hdslb.com/bfs/album/c63ab4a8ba3a15b227fc5644d0c5a28f5b27e9b2.png)

**动态重定位分区分配算法**

内存不足时，**紧凑**

![image-20220430112005572](https://i0.hdslb.com/bfs/album/6d2718c825cec147732a9625ff82f2d512165ff1.png)

### 4.8 基本分页存储管理

分页存储的基本思想：**离散分配**，将程序分为相同大小的块，分别存储

**页框/页帧/内存块/物理块**：内存空间分为的一个个 **大小相等的分区**（**页框不能太大，可能会产生内部碎片，一般为2的幂**）

**页框号/内存块号/页帧号/物理块号：** **页框/页帧/内存块/物理块**的编号，**从0开始**

**页/页面：**将用户进程的地址空间也分为 **与页框大小相等** 的一个个区域

**页号：**页面的编号从0开始

<img src="https://i0.hdslb.com/bfs/album/b3c47e399fe5b93b24db788d1a52136a8d967db0.png" alt="image-20220430113308935" style="zoom: 50%;" />

**如何实现地址转换**

- **物理地址=页面实址+页内偏移量**

- 分页地址中的地址结构如下：

  ![image-20220430114003041](https://i0.hdslb.com/bfs/album/dc726a54d4786fe88f981c51fdc057d1b47b637a.png)

- **若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得：**

  <img src="https://i0.hdslb.com/bfs/album/c027594f40722aebcff9c62c365769eea3a0f890.png" alt="image-20220430114048278" style="zoom:50%;" />

**页表**

​	**操作系统为每个进程建立一张页表**

![image-20220430114612239](https://i0.hdslb.com/bfs/album/75abf1c0061b239add2b4ab29b6fa3722936cfb1.png)



![image-20220430112753137](https://i0.hdslb.com/bfs/album/e569da5a72c9e2e5df43149b2aac9016a4452c0d.png)



### 4.9 基本地址变换机构

- 在系统中设置一个**页表寄存器PTR**，其中存放页表在内存的始址和页表的长度
- 平时，进程未执行时，页表的始址和长度是存放在本进程的**PCB**中，当调度程序调度到某进程时，才将它们装入到页面寄存器中

![image-20220430121243558](https://i0.hdslb.com/bfs/album/b3cc8646269f7470408ea5bbf8b824fe63e1eb81.png)

![image-20220430121438427](https://i0.hdslb.com/bfs/album/07e0b0bcc04b3683d17454a452011c79ca164fb6.png)

 ![image-20220430121701317](https://i0.hdslb.com/bfs/album/50edc5d7a1db59979d7a129349b69c97dceaf433.png)

### 4.10 具有块表的地址变换机构

为了提高地址变换速度，可在地址变换机构中，增设一个具有并行查寻能力的**特殊高速缓冲存储器，又称为“联想存储器”或“快表”（TLB**），用以存放当前访问的那些页表项

![image-20220430122927567](https://i0.hdslb.com/bfs/album/1f225910cbb94220e4516753bdbba18293ee9b40.png)

**对比**

![image-20220430122954057](https://i0.hdslb.com/bfs/album/6a57a3a6c1fb66fdfe9212a84cb5b3dc5cc9622b.png)

### 4.11两级页表

**单级页表存在的问题**

- **页表必须连续存放**

- **页表常驻内存**

**逻辑地址的结构**

<img src="https://i0.hdslb.com/bfs/album/c1bd647c6b607d89252a05f7c13158972c4c412f.png" alt="image-20220430124052796" style="zoom:50%;" />

**两级页表解构**

![image-20220430124238922](https://i0.hdslb.com/bfs/album/3c73a0a52b01c0bbfb0ba234b65ccf92a1cf7d7b.png)

![image-20220430124336482](https://i0.hdslb.com/bfs/album/770baf01bfef631acd1df8cf691d1cab1fa0855d.png)

### 4.12 基本分段存储管理方式

采用 **分页存储管理方式时**，常常会将逻辑相关的部分划分到不同的页面，造成共享、保护困难，于是产生了 **分段** 的思想

**解决问题/优点：**

- **方便编程**
- **分段共享**
- **信息保护**
- **动态链接**
- **动态增长**

**分段**

- **地址结构**

  ![image-20220430125021518](https://i0.hdslb.com/bfs/album/5d1fd1c30b9bcd0d238a5ce457cb0a4529845101.png)

- **段表**

  ![image-20220430125049258](https://i0.hdslb.com/bfs/album/93da807d5ed435a3390bb993b6f1ba6968ed2eeb.png)

**地址变换机构**

![image-20220430125208069](https://i0.hdslb.com/bfs/album/38721117e706f9db3567c943ef7fd749a4d1bf1f.png)



![image-20220430124801168](https://i0.hdslb.com/bfs/album/9444e1f0df111a313ba813abec7b41cc6e0cfef2.png)

### 4.13 段页式存储管理方式

**分段与分页方式的优缺点**

![image-20220430125525806](https://i0.hdslb.com/bfs/album/74c0095ad84ab97d4d57fed89ef3acd6f695f3c1.png)

**基本思想**：

- 将每个进程按逻辑模块分段，再将各段分页

**段页式存储逻辑地址结构**

![image-20220430125944029](https://i0.hdslb.com/bfs/album/c9f76ac14d3722f4aca5ca988ecde4b858483b3f.png)

**地址变换过程**

![image-20220430130126606](https://i0.hdslb.com/bfs/album/45014131adc54c52694682b1110096074d20e71b.png)

**总结**

![image-20220430130156808](https://i0.hdslb.com/bfs/album/6e61dd76837362cb4eacaa8bd44536347c260bbf.png)

## 第五章 虚拟存储器

### 5.1 虚拟存储器概述

实现**内存扩充**的方式，比覆盖和交换更加高级 

![image-20220501212241199](https://i0.hdslb.com/bfs/album/04cadf2e3aec24a949024d52dc9803e6e010fc8c.png)

### 5.2 请求分页存储管理方式

 请求分页管理方式需要解决的问题：

- **系统如何获知进程当前所需页面不在主存**
- 当发现缺页时**，**如何把**所缺页面调入主存**
- 当主存中没有空闲的页框时，为了要接受一个新页，需要把老的一页淘汰出去，**根据什么策略选择欲淘汰的页面**

**页表机制**

![image-20220503114708966](https://i0.hdslb.com/bfs/album/53bb283727636895bfb71adea0f6d577e73aa3e5.png)

- **状态位P**：用于指示该页是否已调入内存，供程序访问时参考
- **访问字段A**：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。
- **修改位M**：表示该页在调入内存后是否被修改过。作为该页换出时是否写回外存的依据。
- **外存地址**：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用

**中断的分类**

![image-20220503115929540](https://i0.hdslb.com/bfs/album/ea451d2a141d050ca72cb3bf2be12c662033bffd.png)

**地址变换机构**

![image-20220503120616264](https://i0.hdslb.com/bfs/album/9c75eb296d0bd617525652f5e6722a6299bbf5c2.png)

![image-20220503121752467](https://i0.hdslb.com/bfs/album/e8014b8d73471420e47c082bd85451bd1f5a9302.png)

### 5.3 页面置换算法

用页面置换算法决定应该换出那个页面

**最佳置换算法（OPT）**

- 被淘汰页面，将是以后永不使用的， 或许是在最长(未来)时间内不再被访问的页面

- eg：

![image-20220503123019245](https://i0.hdslb.com/bfs/album/39a100d7dba49a7b7027b07dafe88c363f0959b7.png)

**先进先出置换算法（FIFO）**

- 每次选中淘汰的页面是最早进入内存的页面
- 会产生 **Belady异常**：为进程分配的物理块数增大时，缺页次数不增反减
- eg：![image-20220503123808620](https://i0.hdslb.com/bfs/album/66cc4eace316c5b827ec15261a9c4f50012530ec.png)

**最近最久未使用置换算法（LRU）**

- 每次淘汰页面是最近最久未使用的页面
- eg：![image-20220503124222379](https://i0.hdslb.com/bfs/album/4ce597371d2657078a0caac87fc014c6b832c22d.png)

**时钟置换算法/最近未用算法（CLOCK/NRU）**

- **页表项**：![image-20220503125738209](https://i0.hdslb.com/bfs/album/b80913d14a3e857e02b5a37e0bdd2d1028384d83.png)

- **实现方法**：![image-20220503125953462](https://i0.hdslb.com/bfs/album/fb268961e78a29aed499dda5f341b64b61100dc1.png)

  

**改进型的时钟置换算法**

- 使用**（访问位，修改位）**的形式表示各页状态，eg：（1，1）表示一个页面近期被访问过，且被修改过

- **算法规则：**![image-20220503130341005](https://i0.hdslb.com/bfs/album/1ea25b63150754808de5d378d2b79eddb195713e.png)

- **淘汰优先级**
  1. 最近没访问，且没修改
  2. 最近没访问，但修改过
  3. 最近访问过，但没修改
  4. 最艰难访问过，且修改过

**总结**

![image-20220503132104842](https://i0.hdslb.com/bfs/album/081c4540c72d124990189c83c2425f22931de769.png)



### 5.4 页面分配策略

驻留集：能保证进程正常运行所需的**最小物理块数**

**总结**

<img src="https://i0.hdslb.com/bfs/album/c571bb915e834b8db3e295be059898c8a6551bd0.png" alt="image-20220503132330589" style="zoom:150%;" />

### 5.5  请求分段存储管理方式

**段表机制**

![image-20220503135452839](https://i0.hdslb.com/bfs/album/7baf797699be84cee70b4d3a7ec6e14b89142e19.png)

**缺段中段机构**

![image-20220512194323903](https://i0.hdslb.com/bfs/album/1af8b5ba30235bb8d151fb540e5fb4c73eaa1f3b.png)

**地址变换机构**

![image-20220512194621069](https://i0.hdslb.com/bfs/album/73890c44efe7c0ed1229d14ac41f68c23f710b8e.png)



## 第六章 输入输出系统（设备管理）

### 6.1 I/O设备的概念和分类

![image-20220512200501550](https://i0.hdslb.com/bfs/album/cf7af0a552673aa8c2e0b19d3403b40ec0e4abea.png)

### 6.2 I/O系统的功能、模型和接口

**I/O的基本功能**

1. **隐藏物理设备的细节**
2. **与设备的无关性**
3. **提高处理机和I/O设备的利用率**
4. **对I/O设备进行控制**
   - 采用**轮询**的可编程I/O方式
   - 采用**中断**的可编程I/O方式
   - 直接存储器访问方式
   - **I/O通道方式**
5. **确保对设备的正确共享**
   - **独占设备——只允许各个进程穿行使用的设备**
   - **共享设备——允许多个进程同时使用的设备**
6. **错误处理**

**I/O软件的层次结构**

![image-20220516195455285](https://i0.hdslb.com/bfs/album/73218af02b436c62347f75e45d7a103209681fd6.png)

![image-20220512221350916](https://i0.hdslb.com/bfs/album/fe16bacc75f218d0dbfd76f5922113ed664d53b2.png)

- **用户层软件：**实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作
- **设备独立性软件：**负责实现与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间
- **设备驱动程序：**与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序
- **中断处理程序：**用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后再恢复被中断进程的现场后返回到被中断进程

**I/O系统中各模块之间的层次视图**

- **I/O系统的上、下接口**
  - **/O系统接口**：是I/O系统与上层系统之间的接口，向上层提供对设备进行操作的抽象I/O命令，以方便高层对设备的使用
  - **软件/硬件(RW/HW)接口**：它的上面是中断处理程序和用于不同设备的设备驱动程序。在它的下面是各种设备的控制器
- **I/O系统的分层**
  - **中断处理程序**：处于I/O系统的底层，直接与硬件进行交互
  - **设备驱动程序**：它处于I/O系统的中间层，是进程与设备控制器之间的通信程序
  - **设备独立性软件：**现代OS中的I/O系统基本上都实现了与设备无关性，也称为与设备无关软件。提高l/O系统的可适应性和可扩展性

**I/O系统接口**

- **块设备接口**

  - 块设备
  - 隐藏了磁盘的二维结构
  - 将抽象命令映射为低层操作

- **流设备接口/字符设备接口**：是流设备管理程序与高层之间的接口，用于控制字符设备的输入或输出

  - 字符设备

  - get和put操作
  - in-control指令

- **网络通信接口**：提供了面向网络的功能

### 6.3 I/O控制器

I/O设备

- **机械部件：**用来指向具体的I/O操作，如按钮、屏幕等
- **电子设备：**通常时电路板

**I/O控制器的功能**

- **接收和识别命令**—控制寄存器；**命令译码**
- **数据交换**—CPU(**总线**)->控制器(**数寄**)->设备
- **标识和报告设备的状态**—**状态寄存器**
- **地址识别**—设备和寄存器地址**；**地址译码器
- **数据缓冲**—用**缓冲器**暂存由CPU传来的数据
- **差错控制**—**差错检测、重发**

![image-20220512201641158](https://i0.hdslb.com/bfs/album/b72fa807f7270db7b3c674487ad55053be5c41e9.png)

**I/O控制器的组成**

![image-20220512202045612](https://i0.hdslb.com/bfs/album/0243dbd5f52f8c7faecb0b6836ec51f9274e803a.png)

**注：**

- 一个I/O控制器课内会对应多个设备
- 数据寄存器 、控制器、状态寄存器可能有多个，且这些寄存器都要有相应的之地址，才能翻遍CPU操作。有些计算值会让这些寄存器占用内存的一部分，称为 **内存映像I/O**；另一些计算机则采用I/O专用地址，即 **寄存器独立编址**

![image-20220512203011607](https://i0.hdslb.com/bfs/album/1678923654b79e9ee6c41eabfcad0ca9a936e75e.png)

![image-20220516201335449](https://i0.hdslb.com/bfs/album/7f733eed51b5886c9cf2540f95c42bb0686c0dad.png)



**I/O通道(I/O Channel)**

- **在CPU和设备控制器之间又增设了I/O通道**。其目的是使一些原来由CPU处理的I/O任务转由通道来承担，从而把CPU从繁杂的I/O任务中解脱出来
- I/O通道是一种 **特殊** 的处理机
  - **指令类型单一**：只能执行有关I/O操作的命令
  - **通道与CPU共享内存**

- 通道类型

  - **字节多路通道(Byte Multiplexor Channel)** 

    ​    是一种按字节交叉方式工作的通道，子通道按 **时间片轮状方式** 共享主通道

    ![image-20220516212808477](https://i0.hdslb.com/bfs/album/3c0391732e94c3f764bd41c7f090fb03914589ee.png)

  - **数组选择通道(Block Selector Channel)** 

    字节多路通道不适于连接高速设备，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送

  - 数组多路通道(Block Multiplexor Channel)

- **瓶颈问题**

  - 由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这又往往使它成为I/O的**瓶颈**，进而造成整个系统吞吐量的下降

  - 解决**瓶颈**问题的最有效的方法，便是增加设备到主机间的通路，而不增加通道
  - eg：<img src="https://i0.hdslb.com/bfs/album/15338b6618c7bab598d3355d172ed76c646003e5.png" alt="image-20220516214046226" style="zoom: 33%;" /><img src="https://i0.hdslb.com/bfs/album/fcd21f87809d0fe1dabd4ebe6873405e9a088cab.png" alt="image-20220516214051950" style="zoom: 53%;" />

### 6.4 中断机构和中断处理程序

中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，没有中断，就不可能实现多道程序，因为进程之间的切换是通过中断来完成的

**中断的简介**

- **中断与陷入**
  - **中断（外中断）**：中断是指CPU对I/O设备发来的中断信号的一种响应，由外部设备引起
  - **陷入（内中断）**：由CPU内部事件所引起的中断

- **中断向量表和中断优先级**
- **对多中断源的处理方式**
  - 屏蔽（禁止）中断
  - 嵌套中断

**中断处理程序**

- **主要工作：**
  - 进程上下文的切换
  - 对处理中断信号源进行测试
  - 读取设备状态和修改进程状态
- 当一个进程请求I/O操作时，该进程将被挂起，知道I/O设备完成了I/O操作后，设备控制器变相CPU发出一中断请求
- **中断处理程序的处理过程**
  - 测定是否有未响应的中断信号，唤醒被阻塞的驱动程序进程    
  - 保护被中断进程的CPU环境。下图为保护中断现场的示意图
  - 分析中断原因、转入相应的设备中断处理程序    
  - 进行中断处理    
  - 恢复被中断进程的现场

<img src="https://i0.hdslb.com/bfs/album/944df4c0e58abc5d808b2e68ddb7a64ebd6c9c88.png" alt="image-20220518120034354" style="zoom:80%;" />



### 6.5 设备驱动程序

**I/O系统的高层与设备控制器之间的通信程序**，其主要任务是接收上层软件发来的**抽象I/O要求**，如read或write命令，再把它转换为具体要求后，**发送给设备控制器**，启动设备去执行

**设备驱动程序的功能**

- 接收由I/O进程发来的命令和参数，并将命令中的抽象要求转换为具体要求
- 检查用户I/O请求的合法性
- 发出I/O命令
- 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理
- 驱动程序还应能够根据用户的I/O请求，自动地构成通道程序

**设备驱动程序的特点**

- 驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序
- 对不同类型的设备应配置不同的驱动程序
- 驱动程序与I/O设备所采用的I/O控制方式紧密相关
- 其中的一部分必须用汇编语言书写
- 驱动程序应允许可重入
- 驱动程序不允许系统调用

**设备驱动程序的处理过程**

![image-20220518120703635](https://i0.hdslb.com/bfs/album/45b4e9089149085fcf296acc7dbb80ef94867a1e.png)



### 6.6 I/O控制方式

**I/O控制方式**

- 使用轮询的可编程I/O方式（程序I/O方式） 
- 使用中断的可编程I/O方式
- DMA方式
- 通道控制方式

**需要注意的问题**

- 完成一次读/写操作的流程
- CPU干预的频率
- 数据传送的单位
- 数据的流向

**使用轮询的可编程I/O方式（程序I/O方式）**

- **轮询**

  CPU一直循环检查状态寄存器的状态

- 优点：实现简单

- 缺点：CPU与I/O设备只能串行工作

  <img src="https://i0.hdslb.com/bfs/album/1ea45a2eaca18ff886fb5878d5f4724a5706ce20.png" alt="image-20220512204830473" style="zoom:50%;" />

**使用中断的可编程I/O方式（中断驱动方式）**

- 引入 **中断机制**
- 等待I/O完成的过程中CPU可以切换到别的进程执行
- 优点：CPU和I/O可以并行执行，**提高了资源利用率及吞吐量**
- 缺点：处理中断资源消耗过多

<img src="https://i0.hdslb.com/bfs/album/0f6866e1e816be306e6f4089278fcbc474e9fd57.png" alt="image-20220512204915982" style="zoom:50%;" />

**DMA方式（Direct Memory Access, 直接存储器访问方式）**

- 数据的传送单位是块

- 数据流向直接从设备直接放入内存，或内存到设备

- 仅在传送一个或多个数据块开始和结束时，才需要CPU干预

- DMA控制器

   <img src="https://i0.hdslb.com/bfs/album/a81657a450ec18d3a7e56dcfb52b30b8383fc697.png" alt="image-20220512210951173" style="zoom:50%;" />

  - **命令/状态寄存器CR**：用于接收从CPU发来的I/O命令或有关控制信息， 或设备的状态
  - **内存地址寄存器MAR**：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。
  - **数据寄存器DR**：用于暂存从设备到内存，或从内存到设备的数据
  - **数据计数器DC**： 存放本次CPU要读或写的字(节)数

- 优点：数据传输以块为单位，数据传输不经过CPU

- 缺点：CPU发出一条I/O指令，只能读/取一个或连续的块

<img src="https://i0.hdslb.com/bfs/album/014718d3c548973c01ac0863ed5ab345e31d65f1.png" alt="image-20220513155403342" style="zoom:67%;" />

**I/O通道方式**

- **通道：**一种 **硬件**，可以理解为 **弱鸡版的CPU**。通道可以识别并执行一系列的 **通道指令**
- **通道程序**：是由系列的通道指令所构成
- **通道指令**：与一般的机器敕令不同，在它的每条指令中包含下列诸信息
  - **操作码**--它规定了指令所执行的操作     
  - **内存地址**--标明字符从内存读/写时的首址
  - **计数**--表明本条指令所要读（或写）数据的字节数
  - **通道程序结束位P**--表示通道程序是否结束。P=1表示本条指令是通道程序的最后一条指令
  - **记录结束标志位R**--R=0表示本通道指令与下一条指令所处理的数据是同属于一个记录；R=1表示这是处理某记录的最后一条指令
- **通道程序执行过程**

![image-20220512211256882](https://i0.hdslb.com/bfs/album/1befdbe655528cb797c25e418ec748edb51f5aac.png)

![image-20220512203604613](https://i0.hdslb.com/bfs/album/8bd19d58f3871fc8e32e03d1858ac3599c0b6673.png)



### 6.7 与设备无关的I/O软件

为了方便用户和提高OS的可适应性与扩展性，I/O系统增加了与设备无关的I/O软件，以实现 **设备的独立性（设备无关性）：应用程序独立于具体使用的物理设备。**为实现设备独立性而引入了**逻辑设备和物理设备**这两个概念

**基本概念**

- 引入 **逻辑设备名**：使用**逻辑设备名称**来请求使用某类设备，在使用中需要 **转换** 为 **物理设备名称**。优点：
  - 设备分配时的灵活性
  - 易于实现I/O重定向

- **LUT（逻辑设备表）**

  通过  **逻辑设备表（LUT）** 来确定逻辑设备对应的 **物理设备**，并找到该设备对应的 **设备驱动程序**

  - 整个系统设置一张LUT，主要用于单用户
  - 为每个用户设置一张LUT，每当用户登录时，便为该用户建立一个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。用于多用户   

<img src="https://i0.hdslb.com/bfs/album/378f326d83324d3638784106e72b6233c4dcbfd5.png" alt="image-20220518131254140" style="zoom:67%;" />



**与设备无关的软件**

- **设备驱动程序的统一接口**
- **缓冲管理**
- **差错控制**
- **对独立设备的分配与回收**
- **独立于设备的逻辑数据块**





### 6.8 设备的分配与回收

**设备分配时应考虑的因素**

- 设备的固有属性

  - 独占设备
  - 共享设备
  - 虚拟设备

- 设备分配算法

  - 先来先服务
  - 优先级高者优先

- 设备分配中的安全性

  - **安全分配方式**

    - 为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒

    - 一个时段内每个进程只能使用一个设备

    - 优点：破坏了 **请求和保持** 条件，不会死锁
    - 缺点：对于一个进程来说，CPU和I/O设备只能串行工作

  - **不安全分配方式**

    - 进程只有在某个I/O请求得不到满足时才会阻塞
    - 一个进程可以同时使用多个设备
    - 优点：进程的计算任务和I/O设备任务可以并行处理，使进程迅速推进
    - 缺点：有可能发生死锁

- **设备独立性/无关性**
- 可使应用程序独立于具体的物理设备，显著改善资源的利用率和可适应性（使用逻辑设备表LUT实现）

**静态分配和动态分配**

- **静态分配：**进程运行前为其分配全部资源，运行结束后归还资源，破坏了 **请求和保持** 条件，不会发生死锁
- **动态分配：**进程运行过程中动态申请设备资源

**设备管理中的数据结构**

- **设备控制表（DCT）：**系统为每个设备配置一张DCT，用于记录设备情况![image-20220513165929823](https://i0.hdslb.com/bfs/album/75e6257248c6a1085ddcb005c7b63c46b3960798.png)

- **控制器控制表（COCT）：**每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理

  ![image-20220513183425532](https://i0.hdslb.com/bfs/album/ecd6e492089bde382274284178647b29986c7907.png)

- **通道控制表（CHCT）：**每个通道对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理

  ![image-20220513183549114](https://i0.hdslb.com/bfs/album/62caf1716c8896f24079dafdc0a5ee2e0d9281df.png)

- **系统设备表（SDT）：**记录了 **系统中全部设备** 的情况，每个设备对应一个表目

  ![image-20220513183714796](https://i0.hdslb.com/bfs/album/776b080e09be65e5674406eb4a659f89ea7c175d.png)

![image-20220513184757913](https://i0.hdslb.com/bfs/album/520d162072cdc521d652b49fe862fc4e49fae4ec.png)



### 6.9 假脱机技术（SPOOLing技术）

- 为了缓和CPU的高速性与I/O设备低速性间的矛盾而引入了脱机输入、 脱机输出技术
- ![image-20220513161638888](https://i0.hdslb.com/bfs/album/406aa9c76f3eb04b34dfba7eab49c0843a85bc10.png)

**假脱机技术/SPOOLing技术**

- 用于将一台独占设备改造成共享设备的一种行之有效的技术
- 使用软件的方式模拟脱机技术
- SPOOLing系统的组成
  - 输入井和输出井
  - 输入缓冲区和输出缓冲区
  - 输入进程SPi和输出进程Spo
  - 井管理程序
- **优点：**
  - 提高了I/O的速度
  - 将独占设备改造为共享设备
  - 实现了虚拟设备功能
- ![image-20220513161852224](https://i0.hdslb.com/bfs/album/83ea2b180dd570872b9716e1610ddaeaf89c912b.png)

**独占式设备——只允许各个进程穿行使用的设备**

**共享设备——允许多个进程同时使用的设备**

**共享打印机**

- 打印机式 **独占是设备**，可以使用SPOOLing技术改造成 **共享设备**

- 由输出进程在**输出井**中为之申请一**空闲盘块区**，并将要**打印的数据送入其中**

-  输出进程再为用户进程申请一张**空白的用户请求打印表**，并将用户的打印要求填入其中，再将该表挂到**请求打印队列**上。

- 若打印机空闲，输出进程将**从请求打印队列的队首取出一张请求打印表**，根据表中的要求将要打印的数据从输出井传送到内存缓冲区，再由打印机打印

![image-20220513163903324](https://i0.hdslb.com/bfs/album/c182ecbe07eb7c34b8b8aa47a6bf5579f8eef20a.png)



![image-20220513161329237](https://i0.hdslb.com/bfs/album/196079ef55028d37a650f921fcf5a7f094ef4b81.png)



### 6.10 缓冲区管理

![image-20220513212841182](https://i0.hdslb.com/bfs/album/07356efdadc25b59221415013ea2897b4e43f34e.png)

**单缓冲**

- 采用 **单缓冲**，操作系统 **在主存中为器分配一个缓冲区**（一般大小为一块）

- **缓冲区中数据非空时，不能往缓冲区中冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以缓冲区中冲入数据，但必须把缓冲去充满以后，才能从缓冲区把数据传出**

  ![image-20220513213753665](https://i0.hdslb.com/bfs/album/98e608bfd3db7b4e7fac884eb380b424f6d74ce9.png)

**双缓冲**

- 为了加快输入、输出速度和提高设备利用率，又引入了**双缓冲工作方式**，也称为**缓冲对换（Buffer Swapping）方式**
- 在设备输入时，**先将数据输入第一缓冲区，装满后便转向第二缓冲区**。此时操作系统可从第一缓冲区中移出数据送用户进程区，接着由CPU对数据进行计算

​	![image-20220513214702970](https://i0.hdslb.com/bfs/album/54cb94b1eb1679c451e451bcbac16f2862e71301.png)

**循环缓冲区**

- 将多个 **大小相等** 的缓冲区链链接成一个 **缓冲队列**

- 组成：

  - **空缓冲区R**
  - **已装满数据的缓冲区G**
  - **现行工作缓冲区C**
  - 指针**Nextg**----指示计算进程下一个可用的缓冲区G
  - 指针**Nexti**----指示输入进程下次可用的空缓冲区R
  - 指针**Current**----指示计算进程正在使用的缓冲区单

  ![image-20220513215042337](https://i0.hdslb.com/bfs/album/55ed836b008de34f24ee2c89d0c251702b7da0f8.png)

**缓冲池**

- **既可用于输入又可用于输出的公用缓冲区**
- 按缓冲区使用状况分为：
  - **空缓冲队列（emq）**
  - **输入队列（inq）**
  - **输出队列（outq）**
- 四种工作缓冲区
  - **用于收容输入数据的工作缓冲区（hin）**
  - **用于提取输入数据的工作缓冲区（sin）**
  - **用于收容输出数据的工作缓冲区（hout）**
  - **用于提取输出数据的工作缓冲区（sout）**

![image-20220513220530072](https://i0.hdslb.com/bfs/album/c5d78550dfc0d8cbc1f9beee5c2cbb7ca3e3dd24.png)

- 工作方式

  - 输入进程请求输入数据

    从**空缓冲队列**中取出一块作为 **收容输入数据的工作缓冲区(hin)** 冲满数据后将缓冲区挂到**输入队列队尾**

  - 计算进程想要取得一块输入数据

    从**输入队列**中取得一块冲满输入数据的缓冲区作为 提**取输入数据的工作缓冲区(sin)** 缓冲区读空后挂到**空缓冲区队列**

  - 计算进程想要将准备好的数据冲入缓冲区

    从**空缓冲队列**中取出一块作为 **收容输出数据的工作缓冲区(hout)** 数据冲满后将缓冲区挂到**输出队列队尾**

  - 输出进程请求输出数据

    从**输出队列**中取得一块冲满输出数据的缓冲区作为 **提取输出数据的工作缓冲区(sout)** 缓冲区读空后挂到**空缓冲区队列**

**总结**

![image-20220513221426272](https://i0.hdslb.com/bfs/album/d75094ec2d71114415609da74bad2e13334aadbd.png)

### 6.11 磁盘存储器管理

**磁盘简述**

- **数据的组织和格式**

  ![image-20220518133050874](https://i0.hdslb.com/bfs/album/1ec1d881d9776e80de90a5f9bfc15eb3e54d2281.png)

  - **磁道**：磁盘旋转时, 磁头的轨迹形成一道道同心圆, 信息就存贮在这些同心圆上。我们把这些同心圆叫做磁道
  - **扇区**：磁道划分成的扇段。每个扇区可以存贮 128×2n个字节, 其中 n = 0,1,2,3
  - **容量**：= 面数×磁道数×每道扇区数×每扇区字节数
  - **交错数**：相邻编号的扇区会交错地排在磁道上的间隔扇区数
  - **注意**：访问磁盘上一个完整磁道，磁盘所转的圈数恰好等于交错数。因此也可以将交错数理解为访问一个完整磁道时磁盘所转的圈数

- 磁盘类型

  - 固定头磁盘
  - 移动头磁盘

- 磁盘访问时间

  - **寻道时间$T_s$**

    这是指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动磁臂的时间$s$与磁头移动$n$条磁道所花费的时间之和，假设磁盘移动时间为$m$:
    $$
    T_s=m×n+s
    $$

  - **旋转延迟时间$T_\tau $**

    指定扇区移动到磁头下面所经历的时间。eg：硬盘的旋转速度为5400r/min，每转需要11.1ms，平均旋转延迟时间为5.55ms

  - **传输时间$T_t$**

    指把数据从磁盘读出或向磁盘写入数据所经历的时间。$b$ 表示每次读/写的字节数；$N$ 表示一条刺刀上的字节数；$r$为硬盘旋转速度
    $$
    T_t = \frac{b}{rN}
    $$

  - **访问时间$T_a$**
    $$
    \begin{align}
    T_a=T_s+T_\tau +T_t\\
    T_a=T_s+ \frac{1}{2r} + \frac{b}{rN}
    \end{align}
    $$

**磁盘调度**

- 基本要求
  - **公平**：一个I/O请求在有限时间内满足
  - **高效**：减少设备机械运动所带来的时间浪费
- 考虑问题
  - 减少寻道时间
  - 减少延迟时间

**常用磁盘调度算法**

- **先来先服务（FCFS）**

  - 优点：公平简单
  - 缺点：平均寻道时间较长

  <img src="https://i0.hdslb.com/bfs/album/b9381ee84f8cbc0f5a31b871055a64e5143fdd39.png" alt="image-20220518221603462" style="zoom:50%;" />

- **最短寻道时间优先（SSTF）**

  寻找距离当前最近的位置

  缺点：会出现 **饥饿** 现象

  <img src="https://i0.hdslb.com/bfs/album/10c129dee400d4e2d2a592d4bc75d43ca6d5b1fe.png" alt="image-20220518222153887" style="zoom:50%;" />

- **SCAN算法（电梯调度算法）**

  <img src="https://i0.hdslb.com/bfs/album/8782b8da4ac1238f62ad3d06470c13639676061f.png" alt="image-20220518222306528" style="zoom:50%;" />

- **循环扫描算法（CSCAN）**

  规定磁头单向移动

  <img src="https://i0.hdslb.com/bfs/album/f589d4134f984a1be44f6354c8846ea0eddc8b3a.png" alt="image-20220518222412664" style="zoom:50%;" />

- **SSTF、SCAN、CSCAN算法** 可能会出现 **磁臂黏着**



## 第七章 文件管理

### 7.1 文件和文件系统

文件系统的管理功能是将其管理的**程序和数据**通过组织为一系列**文件**的方式实现的

文件则是指具有**文件名的若干相关元素**的**集合**

基于文件系统的概念可以将数据组分为 **数据项、记录和文件三级**

- **数据项**

  - 基本数据项
  - 组合数据项

- **记录**：一组相关数据的集合。**关键字** 是能唯一标识一个记录的数据项

- **文件**：是指由创建者所定义的、具有文件名的一组相关信息的集合

  - 文件的分类：

    ![image-20220519184946546](https://i0.hdslb.com/bfs/album/6ac7446cb2db1106a27ec7f5ce7537aa3637f8c9.png)

  - 文件的属性：

    - 文件类型
    - 文件长度
    - 文件的物理位置
    - 文件的创建时间

​	<img src="https://i0.hdslb.com/bfs/album/2000e7b840fca1c3f1da729200fe7e69aad57465.png" alt="image-20220519184744793" style="zoom:50%;" />

**文件系统的层次结构**

<img src="https://i0.hdslb.com/bfs/album/1bb1a6f8e0b0903cbf74058002c4a69b834ed671.png" alt="image-20220519185322016" style="zoom: 50%;" />

- **对象及其属性说明（最底层）**

  - 文件
  - 目录
  - 磁盘存储空间

- **对对象操纵和管理的软件集合（中间层）**

  <img src="https://i0.hdslb.com/bfs/album/c773a2741541fef32429d4145eb0251a5700f003.png" alt="image-20220519185532270" style="zoom:50%;" />

- **文件系统的接口（最高层）**

  - **命令接口**： 这是指作为用户与文件系统交互的接口。用户可通过键盘终端键入命令，取得文件系统的服务
  - **程序接口**： 这是指作为用户程序与文件系统的接口。用户程序可通过系统调用来取得文件系统的服务

**文件操作**

- 最基本的操作

  <img src="https://i0.hdslb.com/bfs/album/f4a35e8141b50f1af73a02cd0435533ce79adc7a.png" alt="image-20220519185641161" style="zoom:50%;" />

- 文件打开/关闭操作
- 其他

**总结**

<img src="https://i0.hdslb.com/bfs/album/17a50df94038c38f01dc8c356fa6b119d83a0f7a.png" alt="image-20220519185832735" style="zoom:67%;" />

### 7.2 文件的逻辑结构

**物理结构**：文件的存储格式，指的是操作系统看来，文件的数据是如何存放在外存的

**逻辑结构**：在用户看来文件是如何组织的

**文件按结构类型分类：**

<img src="https://i0.hdslb.com/bfs/album/41460da469c32aea4f23f8d7b927978d4406233a.png" alt="image-20220519193907796" style="zoom:50%;" />

- 有结构文件：即记录式文件。大量的数据结构和数据库采用此类文件。在此类文件中，记录的长度可分**定长**和**不定长**两类
- 无结构文件：即流式文件。大量的源程序、可执行文件、库函数等采用的是此类文件

**顺序文件**

- 文件中的记录一个接一个的顺序排列

- 分类

  - 串结构：记录之间的顺序与**关键字**无关
  - 顺序结构：文件中的所有记录按**关键字**排序

- 优缺点：

  <img src="https://i0.hdslb.com/bfs/album/6d844c1d837b53ddac58b4997c6c513099afdfe7.png" alt="image-20220519194443148" style="zoom:67%;" />

**记录寻址（针对顺序文件）**

- **隐式寻址方式**：对于定长文件，知道当前文件的逻辑地址，边很容易确定下一个记录的逻辑地址

  <img src="https://i0.hdslb.com/bfs/album/c5ea73f45cb26f45881649b80bfed2e92bb25cf2.png" alt="image-20220519194726680" style="zoom:67%;" />

-  **显示寻址方式**：该方式可用于对定长记录的文件实现直接或随机访问

**索引文件**

- 为可边长文件建立一张 **索引表**

- 对索引文件进行搜索时，用户根据关键字，利用 **折半查找法** 检索索引表

  <img src="https://i0.hdslb.com/bfs/album/c7c39e287f44e556943c7ed182402a3fb3115fe5.png" alt="image-20220519195056743" style="zoom:50%;" />

**索引顺序文件**

- 结合了顺序文件与索引文件的特点

- 引入了 **文件索引表** 和 **溢出文件（用来存放新增加的、删除的和修改的记录）**

- 将顺序文件所有记录分组，在建立一张 **索引表**，每组第一个记录建立一个索引项

  <img src="https://i0.hdslb.com/bfs/album/a6ea2da178cab99a6d39ee93f2bfdae96e9f5e43.png" alt="image-20220519200158628" style="zoom:50%;" />

**直接文件与哈希文件**

- 直接文件：根据给定的**记录键值**，直接获得指定记录的**物理地址**。这种转换被称为 **键值转换**
- 哈希文件：<img src="https://i0.hdslb.com/bfs/album/a02789447848db196cbffab0e14382e4feaaf202.png" alt="image-20220519200415913" style="zoom:43%;" />

### 7.3 文件目录

文件目录的 **最基本功能：**

<img src="https://i0.hdslb.com/bfs/album/cd57f04b36eecaeb16bbb6ad7b26a6dec4a1934c.png" alt="image-20220521135520471" style="zoom:50%;" />

**文件控制块（FCB）**

- 文件控制块包含信息

  <img src="https://i0.hdslb.com/bfs/album/709a601497a58927d8e21bc878cf9564f8a857fb.png" alt="image-20220521135657905" style="zoom:50%;" />

<img src="https://i0.hdslb.com/bfs/album/0df8ed94814bfbb60e33be0b3e710c039d32abd5.png" alt="image-20220521135720608" style="zoom:50%;" />

<img src="https://i0.hdslb.com/bfs/album/06e9e0424ad9b65dba08f90cecd66ef522322582.png" alt="image-20220521135821658" style="zoom:50%;" />

**目录结构**

- 单级文件目录

  实现了 **按名存取**，但 **不允许文件重名**

  ![image-20220521135959821](https://i0.hdslb.com/bfs/album/060142ca795c07f19c959b8605d0db5a385509ab.png)

- 两级文件目录

  为每用户建立一个单独的 **用户文件目录UFD**，它由用户所有文件的文件控制块组成。再在系统中建立一个 **主文件目录MFD**

  <img src="https://i0.hdslb.com/bfs/album/81e384577900e0589e863231669f8984804e42a6.png" alt="image-20220521140205356" style="zoom:50%;" />

​	优点：

​	<img src="https://i0.hdslb.com/bfs/album/1254534ea7e0b22ac0852c87f20100b3ebb55935.png" alt="image-20220521140244140" style="zoom:50%;" />

- **树形目录（多级目录结构）**
  - 路径名：在该路径上从树的根(即主目录)开始，把全部目录文件名与数据文件名，依次地用“/”连接起来
  - 当前目录/工作目录：进程对各文件的访问都是相对于“当前目录”进行的。将路径上的全部目录文件名 与数据文件名用“/”连接而形成的路径名称为**相对路径名**。从树根开始的路径名，称为 **绝对路径名**
  - 树形目录不便于文件共享

​	<img src="https://i0.hdslb.com/bfs/album/e8a98bc59ec79e4d0ef7ab4b0bd75cc81f8433d2.png" alt="image-20220521140340602" style="zoom:50%;" />

**目录操作**

- 创建目录
- 删除目录
  - 不删除非空目录
  - 可删除非空目录
- 改变目录
- 移动目录
- 链接(Link)操作
- 查找

**目录查询技术**

- **线性检索法**
- **Hash方法**

**索引结点（FCB改进）**

- 在文件查找时只考虑文件名
- 提高文件检索速度
- 分类
  - 磁盘索引结点：在外存
  - 内存索引结点：在内存
- ![image-20220521140932263](https://i0.hdslb.com/bfs/album/73224eece7b4fa95296ced48df5e4e6450171df5.png)

**总结**

![image-20220521141209148](https://i0.hdslb.com/bfs/album/7f59059ca3b2ea9bd946b1e772843f6bd79e0ca8.png)

### 7.4 文件共享

**基于有向无循环图实现文件共享**

- **有向无循环图DAG(Directed Acyclic Graph)**

  允许一个文件可以有多个父目录

  <img src="https://i0.hdslb.com/bfs/album/d6a15204e73612c8f42359a18a3d39d9a8c6da34.png" alt="image-20220521141716845" style="zoom:50%;" />

- **利用索引结点（硬链接）**

  - 在文件目录中只设置文件名及指向相应索引结点的指针
  - 在用户删除文件后，索引结点的count-1，只有当count=0时，文件才被真正删除

  ![image-20220521141836963](https://i0.hdslb.com/bfs/album/49d0aa540de4b7fe67113247b80000dfc93f9a24.png)

**利用独好链实现文件共享（软连接）**

- 允许一个文件或子目录有多个父目录，但其中仅有一个作为主（属主）父目录，其他的几个父目录都是通过符号链接的方式与之相链接的（简称链接父目录）

  <img src="https://i0.hdslb.com/bfs/album/0f75e7c8c5b9fe8b0aaab91d8115a4b245ec5843.png" alt="image-20220521142201380" style="zoom:50%;" />

- eg：windos快捷方式

**总结**

![image-20220521143823885](https://i0.hdslb.com/bfs/album/c63265d36a52cab06709bb859985e547416cd315.png)

### 7.5 文件保护

**影响文件安全性的主要因素及解决办法:**

- **人为因素**：通过存取控制机制，防止由人为因素所造成的文件不安全性
- **系统因素**：采取系统容错技术，防止系统部分的故障所造成的文件的不安全性
- **自然因素**：建立后备系统，防止由自然因素所造成的不安全性

**保护域**

- **访问权：**一个进程能对某对象执行操作的权力
- **保护域：** **域** 是进程对一组对象访问权的集合，进程只能在指点续内指向操作。**域** 规定了进程所能访问的对象和能执行的操作

<img src="https://i0.hdslb.com/bfs/album/f4c6f3e67eea0dd74641e8d90845198e4d9af873.png" alt="image-20220521144840062" style="zoom: 50%;" />

- **进程和域之间的静态联系**

  进程和域一一对应

- **进程和域间的动态联系**

  进程和域之间是一对多的联系，可以根据运行中的实际需要规定每个阶段中所能访问的对象

**访问矩阵**

- **基本访问矩阵**

  ![image-20220521145216278](https://i0.hdslb.com/bfs/album/508a7535050dbd9d4721c2f242c3a0921a71e9d0.png)

- **具有域切换权的访问矩阵**

  ![image-20220521145302195](https://i0.hdslb.com/bfs/album/435d160f3be9939688d69fc6bbec6576db5bdd64.png)

**访问矩阵的修改**

- **拷贝权（Copy Right）**

  将一个域对对象所拥有的权限复制给其他域

  eg：![image-20220521145736096](https://i0.hdslb.com/bfs/album/b9bbcd14f1b7eddb922eb5e88d452f7c0d2fe001.png)

- **所有权（Owner Right）**

  拥有所有权（O）可以对对象增加/删除某种访问权

  eg：<img src="https://i0.hdslb.com/bfs/album/9b6f383bcd778773f40fef0409d2d5edebcc194b.png" alt="image-20220521145925508" style="zoom:67%;" />

- **控制权（Control Right）**

  拥有控制权可以改变对应域的所有权限

  eg：![image-20220521150209010](https://i0.hdslb.com/bfs/album/3d7fea1b3e451d82df2071039dd2dea30f77076e.png)

**访问控制表**

- **访问控制表(Access Control List)**：

  对访问矩阵列（对象）划分，为每一列建立一张访问控制表ACL

- **访问权限(Capabilities)表**：

  为每一行（域）构成一张访问权限表

  ![image-20220521150539625](https://i0.hdslb.com/bfs/album/3ddc10e4cec243da1501cca227b067e5be7624a2.png)

## 第八章 磁盘存储器管理

### 8.1 外存的组织方式

磁盘具有 **可直接访问** 的特性，故利用磁盘来存放文件时，具有很大的 **灵活性**

为外存分配空间时考虑的问题：

<img src="https://i0.hdslb.com/bfs/album/e3b45c3412bd362aa8f1dae20d9e620d70d2d5cb.png" alt="image-20220521151714831" style="zoom:50%;" />

**外存组织方式**

- 连续分配
- 链接分配
- 索引分配

**连续分配方式**

- 为每个文件分配一组相邻接的盘块。形成的物理文件为 **顺序文件**
- 保证了文件占用盘块的顺序的 **一致性**
- 优点：
  - **顺序访问容易** 
  - **顺序访问速度快**
- 缺点：
  - **要求为一个文件分配连续的存储空间** 
  - **必须事先知道文件的长度** 
  - **不能灵活地删除和插入记录**
  - **对于那些动态增长的文件很难分配空间**
- <img src="https://i0.hdslb.com/bfs/album/6752ba60b48a3ce763ce2902b092a507c9627c50.png" alt="image-20220521152057620" style="zoom:67%;" />

**链接组织方式**

- 通过每个盘块上的 **链接指针**，将文件形成一个 **链表**，这种文件称为 **链接文件**

- 链接方式

  - **隐式链接**

    文件目录的每个目录项，包含指向链接文件的 **第一个盘块** 和 **最后一个盘块**

    <img src="https://i0.hdslb.com/bfs/album/9d97ee6ba238f4b440d57418c1da9efe1608b494.png" alt="image-20220521152444478" style="zoom:67%;" />

  - **显示链接**

    - 将用于链接文件各物理块的指针，显式的放在内存的一块链接表中，整个磁盘仅设置一张，将该表称为 **文件分配表FAT**

    <img src="https://i0.hdslb.com/bfs/album/2160075d4dd4e5811a017f7bbf0ad8ddf69ea530.png" alt="image-20220521152727434" style="zoom:67%;" />

- **问题：**
  - 不能支持高效的直接存取
  - FAT表需占用较大的内存空间

**FAT技术**

- FAT12
- FAT16
- FAT32

**NTFS技术**

- NTFS是以簇作为磁盘空间分配和回收的基本单位的。一个文件占用若干个簇，一个簇只属于一个文件
- 以卷为单位，将一个卷中的所有文件信息、目录信息以及可用的未分配空间信息，都以文件记录的方式记录在一张主控文件表MFT(Master File Table)中

**索引组织方式**

- **单极索引**

  - **索引分配方法**为每个文件分配一个**索引块（表）**，把分配给该文件的所有盘块号，都记录在该索引表中，因而该索引块就是一个含有许多盘块号的数组

  - **问题：**可能要花费较多的外存空间

    <img src="https://i0.hdslb.com/bfs/album/19a85d48d756edda6647eef2e77989727c86b63f.png" alt="image-20220521153607126" style="zoom:50%;" />

- 多级索引

  <img src="https://i0.hdslb.com/bfs/album/86d453ebac4bb7c1fad109a662c2f2500661f416.png" alt="image-20220521153635335" style="zoom:67%;" />

- 混合索引

  是指将多种分配方式**相结合**而形成的一种分配方式。它们把所有的地址项分成两类，即**直接地址**和**间接地址**

  <img src="https://i0.hdslb.com/bfs/album/72203bf64104f9581edebca664b79a7235d33696.png" alt="image-20220521153728924" style="zoom:67%;" />

### 8.2 文件存储空间的管理

**空闲表法和空闲链表法**

- **空闲表法**

  使用**首次适应算法、循环首次适应算法**等分配

  ![image-20220521153907103](https://i0.hdslb.com/bfs/album/ad3628aff07ee6277de2e2b6257b22694b84da85.png)

- **空闲链表法**

  是将所有的**空闲盘区**拉成一条**空闲链**。根据构成链的基本元素的不同，可有两种链表方 式：**空闲盘块链**、**空闲盘区链**

  - 空闲盘块链：将所有的空闲 **盘块** 链成一条链
  - 空闲盘区链：将空闲的盘块组合链接

**位示图法**

- 使用二维表表示盘块，1 已分配，0空闲

- eg：

  |      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 1    | 0    | 1    | 1    | 1    | 0    |
  | 2    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    |
  | 3    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    |
  | 4    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
  | ┇    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
  | 16   |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

**成组织链法**

- 空闲表法和空闲链法，都不适合用在大型文件系统中。在UNIX中采用的**成组链接法**兼备了两种方法的优点而克服了两种方法均有的、表太长的缺点

  <img src="https://i0.hdslb.com/bfs/album/081e3ddfb339d2b81bf9cb4b5f74f722a6b164f1.png" alt="image-20220521154553050" style="zoom:50%;" />



### 8.3 提高磁盘I/O的途径

**降低文件访问时间三种途径**

- 改进文件的目录结构以及检索目录的方法来减少对目录的查找时间
- 选取好的文件存储结构，以提高对文件的访问速度
- 提高磁盘的I/O速度，能将文件中的数据快速地从磁盘传送到内存中，或者相反**（本章重点介绍）**

**提高I/O的途径**

- **磁盘高速缓存(Disk Cache)** 
- **廉价磁盘冗余阵列(RAID)** 

### 8.4 提高磁盘可靠性的技术

**第一级容错技术SFT-Ⅰ**

- 用于防止因磁盘表面缺陷所造成的数据丢失
- **双份目录和双份文件分配表**
- **热修复重定向和写后读校验**：用于补救磁盘表面有少量缺陷

**第二级容错技术SFT-Ⅱ**

- **磁盘镜像(Disk Mirroring**：   为了避免**磁盘驱动器/控制器**发生故障而丢失数据，便增设了磁盘镜像功能
- **磁盘双工(Disk Duplexing)**

**基于集群技术的容错功能**

- **双机热备份模式**

  <img src="https://i0.hdslb.com/bfs/album/0d253b8f82378e74734ace2d277a0babed5e0402.png" alt="image-20220521155243133" style="zoom:50%;" />

- **双机互为备份模式**
- **公用磁盘模式**

**后备系统**

- **磁带机**
- **硬盘**
- **光盘驱动器**



### 8.5 数据一致性控制

**事务**

- **事务的定义**：事务是用于访问和修改各种数据项的一个程序单位。事务也可以被看做是一系列相关读和写操作
- **事务记录(Transaction Record)**：用来记录在事务运行时数据项修改的全部信息，故又称为运行记录(Log)
- **恢复算法**

**检查点**

- **检查点(Check Points)的作用**：清理事务记录
- **新的恢复算法**：在引入检查点后，可以大大减少恢复处理的开销

**并发控制(Concurrent Control)**

- **利用互斥锁实现“顺序性”**
- **利用互斥锁和共享锁实现顺序性**

**重复数据的数据一致性问题**

- **重复文件的一致性**
- **链接数一致性检查**
