#  操作系统

[TOC]

## 第一章 操作系统引论

### 1.1 操作系统的目标与作用

![image-20220301204325966](https://i0.hdslb.com/bfs/album/8174d2008c5d6d610beb8a0c62be4fe12bd572b4.png)

**操作系统的组成**

- 硬件系统（裸机）：CPU、存储器（主存、辅存）、输入/输出设备等
- 软件系统：系统软件、应用软件
- 系统软件：管理计算机本身的操作。如操作系统、编译…   
- 应用软件：提供给用户进行解题。如科学计算、事物管理…

**计算机系统的层次结构**

![image-20220301204831542](https://i0.hdslb.com/bfs/album/22590ce4b0804903124972a3e9c70ca13a2d9a5f.png)

- 计算机系统由硬件和软件组成 
- 操作系统是在硬件基础上的第一层软件 
- 操作系统是其他软件和硬件之间的接口 

**操作系统的定义**

 操作系统是计算机系统中的一个**系统软件**，是一些程序模块的集合。使得用户能够**灵活、方便、有效**地使用计算机，使整个计算机系统能高效地运行，从而在计算机与用户之间起到**接口**的作用。  

**操作系统的目标**

- 方便性
- 有效性
- 可扩充性
- 开放性

**操作系统的作用**

- **OS作为用户与计算机硬件系统之间的接口**

  提供功能

  - 命令接口
    - 联机命令接口
    - 脱机命令接口
  - 程序接口
  - GUI（图形用户界面）

  目标：方便用户使用

  ![image-20220301210529405](https://i0.hdslb.com/bfs/album/096de00fd8d644cd277cc17d1a5706aebff1ff68.png)

- **OS作为计算机系统资源的管理者**

  **提供的功能**

  - 处理机管理
  - 存储器管理
  - I/O设备管理
  - 文件管理

  目标：高效、安全

- **OS用作扩充机器**



![image-20220306125744139](https://i0.hdslb.com/bfs/album/e297fb4a9d3e962bd01ecc669708d5063c489b94.png)

### 1.2 操作系统的发展

- **人工操作方式**

  **主要缺点**：用户独占全机、人机速度矛盾导致资源利用率极低

- **单道批处理系统**

  引入 **脱机输入/输出技术**（用磁带机完成），并 **监督程序负责**（操作系统的雏形） 负责控制作业的输入与输出

  **主要优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升

  **主要缺点**：系统中的资源得不到充分的利用。在**内存中仅有一道程序**，只有该程序运行结束之后才能调用下一道程序。**CPU由大量时间是在空闲等待I/O完成**

  ![image-20220301212104513](https://i0.hdslb.com/bfs/album/16879a73be50f679e87baadb9d6850ac9d44c1a2.png)

- ##### 多道批处理系统

  每次往内存中输入多道程序，操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行

  **主要优点：**多道程序 **并发** 执行，**共享** 计算机资源。**资源利用率大幅提升**，CPU和其他资源保持“忙碌”状态，系统吞吐量增大

  **主要缺点：**用户响应时间长，**没有人机交互功能**

- **分时操作系统**

  计算机以 **时间片** 为单位 **轮流为各个用户/作业服务**，各用户可以通过终端与计算计进行交互

  **主要优点：**用户请求可以解释被相应，**解决了人机交互问题**。允许多个用户同时使用一台计算机

  **主要缺点**：**不能优先处理一些紧急任务**

- **实时系统**

  实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，**在规定的时间内完成对该事件的处理**，并控制所有实时任务协调一致地运行。实时操作系统的主要特点是 **及时性和可靠性**

- **实时系统与分时系统的比较**

  ![image-20220302211655131](https://i0.hdslb.com/bfs/album/8ac89dfc7a25e4a5cde2609a1a6bc2281cdf717c.png)

![image-20220306135445037](https://i0.hdslb.com/bfs/album/4a271f6b79d7e33baf13caab7e65f0adde42fb92.png)

### 1.3 操作系统的基本特性

1. **并发性（Concurrence）**

   - **并行性**是指两个或多个事件在同一时刻发生
   - **并发性**是指两个或多个事件在同一时间间隔内发生（**宏观上同时，微观上交替**）
   - **进程**是指在系统中能独立运行并作为资源分配的基本单位

2. **共享性（Sharing）**

   **共享**是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用

   - **互斥共享方式**（一个时间段内只允许一个进程访问该资源）
   - **同时共享方式**（允许一个时间段内由多个进程“同时”访问该资源）

3. **虚拟性（Virtual）**

   操作系统中的所谓**虚拟**，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物

   eg：空分复用技术，时分复用技术

4. **异步性（Asynchronism）**

   进程是以人们不可预知的速度向前推进，此即进程的**异步性**

**注：**

1. 如果失去并发性，则系统只有一个层序正在运行，则共享性失去意义
2. 如果失去共享性，则两个程序就不能同时访问硬盘资源，就无法同时发送文件，也就无法并发
3. 只有系统拥有并发性，才有可能导致异步性

![image-20220306132003819](https://i0.hdslb.com/bfs/album/b019858838297b843d19b3242c04c399a45f5af3.png)

### 1.4 操作系统的主要功能

1. **处理机管理功能**
   1. **进程控制**：进程控制的主要功能是创建进程、撤销已结束的进程，以及控制进程在运行过程中的状态转换
   2. **进程同步**：为使多个进程能有条不紊地运行，系统中必须设置相应的进程同步机制。进程互斥方式、进程同步方式
   3. **进程通信**
   4. **调度**
2. **存储器管理功能**
   1. **内存分配**
      -  为每道程序分配内存空间，使它们“各得其所“
      - 提高存储器的利用率，尽量减少不可用的内存空，允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。OS一般采用静态和动态两种分配方式
   2. **内存保护**
   3. **地址映射**
   4. **内存扩充**


## 第二章 进程的描述与控制
### 2.1 前驱图和程序执行

**前驱图**

- 用于描述一个 **程序** 的各部分见的依赖关系，或者一个大的 **计算** 的各个子任务间的因果关系

- 前驱图不允许有循环
- eg：![image-20220312172227862](https://i0.hdslb.com/bfs/album/f5c8cdd037ad0a7d5bd01398aafb1ca9f353a691.png)

**程序顺序执行**

- 仅当前一操作执行后，才能执行后继操作
- 特点：
  - **顺序性**：一个程序的各个部分的执行，严格地按照某种先后次序执行
  - **封闭性**：程序运行时独占全部系统资源
  - **可再现性**：

**程序并发执行**

- 对一批程序进行处理时，可以并发执行
- 特征：
  - **间断性**：程序内部资源相互制约，导致并发程序具有 **执行-暂停-执行**
  - **失去封闭性**：多个程序共享系统中的各种资源
  - **不可再现性**

### 2.2 进程的描述
**进程、进程实体的定义**

- **程序：**一个指令序列

- 为了方便操作系统管理，完成程序的并发执行，引入了 **进程、进程实体** 的概念
- 系统为每个运行程序配置一个数据结构，称为 **进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放的位置）
- **进程实体（进程映像，简称为“进程”）**静态
  - **PCB**、**程序段**，**数据段** 三部分所构成
  - **创建进程** 就是进程实体中的PCB，**撤销进程** 就是撤销进程实体中的PCB
  - **PCB时进程存在的唯一标志**
- **进程的定义 ** 动态
  - **进程**是程序的**一次执行**，该程序可以与其它程序**并发执行**
  - **进程**是进程实体的 **运行过程**，是系统进行 **资源分配** 和 **调度** 一个独立单位

**进程与程序的区别**

- 程序是静态文本，进程是动态过程 

- 一个进程可以执行一个或多个程序，几个进程可以同时执行一个程序
- 程序可作为软件资源长期保存，进程只是一次执行过程，是暂时的，不能长期保存
- 进程是系统分配调度的独立单位，能与其他进程并发执行 

**进程的组成**

- **进程（进程实体）有PCB、程序段、数据段组成**
- 讨论进程 **内部的构成**

<img src="https://i0.hdslb.com/bfs/album/6747b68354af72301e5448161ff8b90a4725783e.png" alt="image-20220312175828498" style="zoom:80%;" />

**进程的组织**

- 讨论 **多个进程之间** 的组织方式问题

- **链接方式**

  <img src="https://i0.hdslb.com/bfs/album/6f40828643a94b4b41c64ecf2369a7282366a1d8.png" alt="image-20220312180304348" style="zoom:80%;" />

- **索引方式**

  <img src="https://i0.hdslb.com/bfs/album/e3a0720e66a60ccccedc700b5f0741394f46fccf.png" alt="image-20220312180348450" style="zoom:80%;" />

<img src="https://i0.hdslb.com/bfs/album/7b279c258df5e0556a6792bb31776f8751d44a00.png" alt="image-20220312180106140" style="zoom:67%;" />

**进程的特征**

<img src="https://i0.hdslb.com/bfs/album/1a756793bb9df5882ef69344d4cda7ab2fadae73.png" alt="image-20220312180642566" style="zoom:80%;" />

**总结**

<img src="https://i0.hdslb.com/bfs/album/ad40f8031dc8b4e81c96a8ccc8da72e69745b311.png" alt="image-20220312180851861" style="zoom:80%;" />



### 2.3 进程的状态与转换

**进程的三种基本状态**

- **就绪状态**：拥有除了处理机（CPU）之外的所有资源
- **执行状态**：就绪状态拥有处理机（CPU）
- **阻塞状态**：因等待某一事件而暂停不能运行

**创建状态与终止状态**

- **创建状态**
  就绪状态之前的总和：进程正在被创建，操作系统为进程分配资源、初始化PCB
- **终止状态**
  进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

**挂起状态：**暂时调到**外存**等待的进程状态

**进程状态的转换**

**五状态**

![image-20220314102355716](https://i0.hdslb.com/bfs/album/ddb7617dbfbed2ca9da89aa7c5fd4c99f1f70696.png)

**七状态**

![image-20220412215737075](https://i0.hdslb.com/bfs/album/66c339c2c1c2e0abdd520b8b2662d880a6f1562e.png)

**总结**

![image-20220314102424142](https://i0.hdslb.com/bfs/album/ceb9ac8428d6398f09f0dcb44a8c21b7cc5771c7.png)

### 2.4 进程控制

**进程控制** 的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能（**反正进程控制就是要实现进程状态转换**）

![image-20220314103452546](https://i0.hdslb.com/bfs/album/94ff80337fa3566e7365586874935bf08ab69dc1.png)

- 用 **原语** 实现进程控制。原语的特点是执行期间 **不允许中断**，只能一气呵成。这种不可被中断的操作即 **原子操作**

- 原语采用 **关中断指令** 和 **开中断指令** 实现

  <img src="https://i0.hdslb.com/bfs/album/5e108bb5fdc42f35f44344637612a73abb8f0ec6.png" alt="image-20220314104802218" style="zoom:67%;" />

三类**原语**

- 更新PCB信息
- 将PCB插入合适的队列
- 分配/回收资源

**进程的创建**

![image-20220314105544150](https://i0.hdslb.com/bfs/album/4a2ac6266645b7a99ad78b18686030a54672a1de.png)

**进程的终止**

![image-20220314105753300](https://i0.hdslb.com/bfs/album/d153d723354fdd555e97f878f16e59fa0cebc43f.png)

**进程的阻塞和唤醒**

![image-20220314105920442](https://i0.hdslb.com/bfs/album/1787a7bc520a0e01ef37b1f690ba162da28dc65d.png)

**进程的切换**

![image-20220314110043835](https://i0.hdslb.com/bfs/album/36058f4333e6f7254f9f407e9059186a1c342164.png)

**总结**

![image-20220314110147657](https://i0.hdslb.com/bfs/album/c5d9f8becca283df4f0d0ab2505dc5ed3e72facd.png)

### 2.5 进程同步与进程互斥

- 在多道系统中，由于资源共享或进程合作，使进程间形成 **间接相互制约** 和 **直接制约关系**，这是需要用 **进程互斥与同步机制** 来协调两种制约关系

- 为什么要有进程同步：**进程的异步性**

- **同步** 亦称 **直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上 **协调** 它们的 **工作次序** 而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

- **互斥** 亦称 **间接制约关系**，它是指当一个进程访问某临界资源时，另一想要访问该临界资源的进程必须等待。

**临界资源**

- 定义：**一个时间段内只允许一个进程使用**的资源。许多物理设备（如摄像头、打印机），许多变量、数据、内存缓冲区等都属于临界资源。

- 对于临界资源的访问必须 **互斥** 的进行

- 为实现对 **临界资源** 的互斥访问，因保证诸进程互斥地进入自己的 **临界区**。把每个进程中访问临界资源的那段代码称为 **临界区**。为此，每个程序在进入其 **临界区** 前，必须先申请，经允许后方能进入

- 对 **临界资源** 进程 **互斥访问** 的原则：

<img src="https://i0.hdslb.com/bfs/album/99625234d10cf723855e3c9f0d2c6bba800eb040.png" alt="image-20220319152907607" style="zoom:67%;" />



**总结**

<img src="https://i0.hdslb.com/bfs/album/89cd6cf46aa0d1b715add24207aee54825d7905d.png" alt="image-20220319153010289" style="zoom:80%;" />

### 2.6 进程互斥的硬件实现方法

**中断屏蔽方法**

- 利用 **开/关中断指令** 实现

- 优点：简单、高效
- 缺点
  1. 滥用关中断权力可能导致严重后果
  2. 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力
  3. **不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程**

<img src="https://i0.hdslb.com/bfs/album/4d8fce51209733381e21051b798845e4fc8d74ae.png" alt="image-20220319153307014" style="zoom: 67%;" />

**Test-and-Set指令**

简称 **TS指令或TSL指令**

- TSL指令 **是用硬件实现的**，执行过程不允许被中断，只能一气呵成。以下是c语言描述逻辑

```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true 表示已加锁，false表示未加锁
bool TestAndSet(bool *lock)
{
    bool old;
    old = *lock;	//old用来存放lock原来的值
    *lock = true;	//无论之前是否已加锁，都将lock设为true
    return old;		//返回lock原来的值
}

//以下是使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));	//上锁并检查
临界区代码段...
lock = false;	//解锁
剩余区代码段...
```



**Swap指令**

- 有的地方也叫Exchange指令，或简称XCHG指令
- Swap指令 **使用硬件实现的**，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑

```c
//Swap指令的作用是交换两个变量的值
void Swap(bool *a, bool *b)
{
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

//以下是用Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while(old == true)
    Swap(&lock, &old)；
临界区代码...
lock = false;
剩余区代码...
```



逻辑上来看**Swap**和**TSL**上并无太大差别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old，若old为flase则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区



**Swap**和**TSL**

- 优点：实现简单；适用于多处理机环境
- 不满足 **让权等待** 原则



**总结**

![image-20220319160209180](https://i0.hdslb.com/bfs/album/f7bc9070f887f3c3e803c403c49f966691d809fd.png)



### 2.7 信号量机制

- 之前的所有方法 **无法实现“让权等待”**
- 用户进程可以通过使用操作系统提供的 **一对原语(执行只能一气呵成)** 来对 **信号量** 进行操作，从而方便的实现进程互斥、进程同步
- **信号量** 就是一个变量，可以用一个信号量来 **表示系统中某种资源的数量**

- **一对原语**：**wait(S)** 原语和 **signal(S)** 原语，可以吧原语理解为函数，函数名为wait和signal,括号里的 **信号量S** 其实是参数

- wait、signal原语常 **简称为P、V操作**

 

**整形信号量**

- 用一个 **整数型的变量** 作为信号量，用来 **表示系统中某种资源的数量** 
- 对信号量的操作只有三种：**初始化、P操作、V操作**
- **检查** 和 **上锁** 一气呵成，避免了并发、异步导致的问题
- 存在问题：不满足 **让权等待** 原则，会发生 **忙等**

```c
int S = 1;	//初始化整形信号量，表示资源数

void wait(int S){	//wait原语（P操作），相当于请求分配资源
    while(S <= 0) ;
    S=S-1;
}

void signal(int S){	//signal原语（V操作），相当于释放单位资源
    S=S+1;
}

eg：
进程P0:
...
wait(S);	//进入区，申请资源
使用资源	 //临界区，访问资源
signal(S);	//退出区，释放资源
...
```



**记录型信号量**

- 为解决 **整型信号量忙等** 的问题，人们提出了 **记录型信号量**
- **申请资源时**： 如果剩余资源数不够，使用**block原语**使进程从运行态进入阻塞态，并把挂到信号量S的**等待队列（阻塞队列）**中
- **释放资源后：**若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程**从阻塞态变为就绪态**

```c
//记录型信号量的定义
typedef struct{
    int value;			//剩余资源数
    struct process *L;	//等待队列
}semaphore;

//某进程需要使用资源时，通过wait原语申请
void wait(semaphore S){
    S.value--;
    if(S.value < 0){
        block(S.L);
    }
}

//进程使用完资源后，通过signal原语释放
void signal(semaphore S){
    s.value++;
    if(S.value<=0){
        wakeup(S.L);
    }
}
```

**AND型信号量**

**信号量集**

**总结**

<img src="https://i0.hdslb.com/bfs/album/27ba0dc8e2fc425b4e5e933eaa9d3f93dded25ef.png" alt="image-20220319182254741" style="zoom: 80%;" />

### 2.8 用信号量实现进程互斥、同步、前驱关系

**互斥实现**

1. 发现进程关键活动，划定临界区
2. 设置 **互斥信号量** mutex, **初值为1**

3. 在临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

- 注：**P、V操作必须成对出现**

**同步实现**

- **使本来异步并发的程序，有序运行**

1. 分析什么地方需要实现 **同步关系**，集必须保证一前一后执行的两个操作
2. 设置 **同步信号量S，初始为0**
3. **在前操作之后执行V(S)**
4. **在后操作之前执行P(S)**



**前驱关系**

<img src="https://i0.hdslb.com/bfs/album/e306e8fc431a229049522244e29eedb617da0c80.png" alt="image-20220319220548441" style="zoom:67%;" />

使程序按以上顺序执行

1. **为每一都前驱关系各设置一个同步变量**
2. **在前操作之后对相应的同步变量执行V操作**
3. **在后操作之前对相应的同步变量执行P操作**

**总结**

![image-20220319221140585](https://i0.hdslb.com/bfs/album/042cdaa4e8489227a9d8500741c0394197c11d6e.png)

### 2.9 生产者-消费者问题

**问题描述**：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（这里的产品，可以理解为某种数据）。

- 生产者、消费者共享一个初**始为空、大小为n的缓冲区**
- 只有**缓冲区没满**时，生产者才能包产品放入缓冲区，否则必须等待（**同步**）
- 只有**缓冲区不空**时，消费者才能从中取出产品，否则必须等待（**同步**）
- 缓冲区是临界资源，各进程必须 **互斥的访问**

```c
semaphore mutex = 1;	//互斥信号量
semahpore empty = n;	//同步信号量，表示空闲缓冲区个数
semahpore full = 0;		//同步信号量，表示产品数量

profucer(){
    while(1){
        生产一个产品;
        P(empty);	//消耗一个空闲缓冲区
        P(mutex);
        把产品放入缓冲区;
        V(mutex);
        V(full);	//增加一个产品
    }
}

consumer(){
    while(1){
        P(full);	//消耗一个产品
        P(mutex);
        从缓冲区取出一个产品;
        V(mutex);
        V(empty);
        使用产品;
    }
}
```

![image-20220321103316253](https://i0.hdslb.com/bfs/album/1d483405badc993ac96db1877878d65b2f114f2e.png)







### 2.10 进程通信

- **进程通信就是指进程之间的信息交换**

- 为了保证安全，**一个进程不能直接访问另一个进程的地址空间**

- 但是进程之间的信息交换又是必须的，为了保证进程间的安全通信，操作系统提供了一些方法：**共享存储、消息传递、管道通讯**

**共享存储：**

- 两个进程对共享空间的 **访问** 必须是 **互斥的**
- **基于数据结构的共享**：比如共享空间里只能放一个长度为10的数组。这种共享凡是速度慢、限制多，是一种 **低级通信** 方式
- **基于存储器的共享**：在内存中画出一块共享存储区，数据的形式、存放的位置都有进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种 **高级通信** 方式

**管道通信**

![image-20220321110226838](https://i0.hdslb.com/bfs/album/57acdd25c7809700a3e80f2170c7823de2e0f787.png)

- 管道只能采用 **半双工通信**，某一段时间内只能实现单向的传输。如果要实现 **双向同时通信**，则 **需要设置两个管道**
- 各进程要 **互斥** 的访问管道
- 数据以字符流的形式写入管道，当 **管道写满** 时，**写进程**的write()系统调用将被 **阻塞**，等待读进程将数据取走。当读进程将数据全部去走后，**管道变空**，此时 **读进程**的read()系统调用将被 **阻塞**
- **如果没写满，就不允许读。如果没读空，就不允许写**
- 数据一点被读出，就从管道中被抛弃

**消息传递**

- 进程间的数据交换以 **格式化的消息(Message)**为单位。进程通过操作系统提供的”发送消息/接收消息“了两个 **原语** 进行数据交换

<img src="https://i0.hdslb.com/bfs/album/9d0e8e7a06582ac5c784c50d0909291f54817a84.png" alt="image-20220321111136888" style="zoom:80%;" />

**总结**

![image-20220321111307701](https://i0.hdslb.com/bfs/album/c7db512a61aa6e404fe4401acdba7e374cd0574c.png)

### 2.11 线程概念 多线程模型

**什么是线程**

- 可以将线程理解为”轻量级进程“，作为 **调度和分配的基本单位**
- **线程是一个基本的CPU执行单元，也是程序执行流的最小单位**
- **进程内的各线程之间也可以并发，从而进一步提升了系统的并发度**
- **引入线程后，进程只作为除CPU之外的系统资源分配单元**

<img src="https://i0.hdslb.com/bfs/album/1834e080f28fd491538a3094aac4fae71a0e5374.png" alt="image-20220321120032741" style="zoom:80%;" />

**线程的属性**

<img src="https://i0.hdslb.com/bfs/album/f4833b90c68ea49c689ab945dd151d94c2032a22.png" alt="image-20220321120244533" style="zoom:80%;" />

**线程的实现方式**

- **用户级线程（ULT）**
  - **用户级线程**由应用程序通过线程库实现
  - 所有的 **线程管理工作** 都由 **应用程序负责**（包括选曾切换）
  - 用户级线程中，**线程切换**可以在 **用户态下即可完成**，无需操作系统干预
  - 用户级线程对用户来说不透明，对操作系统透明（操作系统只能看见相应的线程）
  - **用户级线程就是从用户视角可以看到的线程**
  - **优点：**
    - 线程切换不需要转换到内核空间
    - 调度算法可以是进程专用的
    - 用户级线程的实现与OS平台无关
  - **缺点：**当一个用户级线程被阻塞后，整个进程会被阻塞，并发度不高。多个线程不能在多核处理器上并发执行

![image-20220412200057197](https://i0.hdslb.com/bfs/album/6234e96e429f9fc56af8464fc2878d1fa84bac07.png)

- **内核级线程（KLT）**
  - 内核级 **线程的管理工作由操作系统内核** 完成。**内核级线程的切换**必须在 **核心态** 下完成
  - **操作系统可以看到内核级线程**
  - **优点：**
    - 在多处理器系统中，内核能够同时调度同一进程中的多**个线程并行执行**
    - 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程
    - 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，**切换开销小**
    - 内核本身也可以采用多线程技术，可以**提高系统的执行速度和效率**

![image-20220412200330480](https://i0.hdslb.com/bfs/album/87b9e48ce972e2eec4d1fad3788305616c5bd236.png)

- **组合方式**
  - 将n个用户级线程映射到m个内核级线程上(n>=m)
  - **优点：**克服了并发度不高，占用资源大的缺点

![image-20220412201217326](https://i0.hdslb.com/bfs/album/9baefb660ae8a5ef53668d65dea97f7f5db39ca1.png)

- **重点：内核级线程才是处理机分配的单位**

  

**总结**

![image-20220412202152685](https://i0.hdslb.com/bfs/album/379c54c3943cb569535af400e41fafec58118558.png)

## 第三章 处理机调度与死锁

### 3.1 处理机调度的层次和调度算法的目标

**调度的基本概念:** **调度** 的实质是一种资源分配，**处理机调度** 是对处理机资源进行分配。**处理机调度算法**是指根据处理机分配策略所规定的处理机分配算法

**调度的三个层次**

- **高级调度（作业调度）**

  由于内存空间优先，因此就需要确定某种规则界定将**作业调入内存的顺序**

- **中级调度（内存调度）**

  引入**虚拟存储技术**之后，可以将暂时不能运行的进程调至外存等待。**中级调度**就是决定 **把那些暂时不能运行的进程，调至外存等待（挂起状态，PCB不会调入外存）**。主要目的是**提高内存利用率和系统吞吐量**

- **低级调度（进程调度）**

  按照某种方法和策略从就绪队列中选取一个进程，交给处理机

- **三层调度的联系、对比**

![image-20220412220016012](https://i0.hdslb.com/bfs/album/b7c88a9f6e2642882035d9530aa9d73d8b30b0ab.png)

**处理机调度算法的目标**

- **共同目标**

  - 资源利用率
  - 公平性

  - 平衡性
  - 策略强制执行
- **批处理系统的目标**
  - 平均周转时间短 
  - 系统吞吐量高
  - 处理机利用率高
- **分时系统的目标**
  - 响应时间快
  - 均衡性
- **实时系统的目标**
  - 截止时间的保证
  - 可预测性

**调度算法的评价指标**

![image-20220416132346844](https://i0.hdslb.com/bfs/album/f463bdb17c9379e0fce189d2b2db3d67638e07ab.png)

### 3.2 作业和作业调度

**作业（Job）：**不仅包含程序和数据，而且还应有作业说明书。系统根据说明书对程序的运行进行控制。是以作业为基本单位从外存调入内存的

**作业步(Job Step)：**在作业运行期间，每个作业都必须经过若干个相对独立又相互关联的顺序加工步骤才能得到结果，其中的每个加工步骤称为一个作业步

**作业控制块（JCB）：**是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息

**作业运行的三个阶段和三种状态：** 

- 收容阶段	后备状态
- 运行阶段	运行状态
- 完成阶段	完成状态

**作业调度的主要任务：**在每次执行作业调度是，做出以下两个决定

- 接纳多少个作业
- 接纳那些作业

**先来先服务（FCFS）**

- 该算法是**最简单的调度算法**，既适用于**作业调度**，也适用于**进程调度**

  ![image-20220416114210859](https://i0.hdslb.com/bfs/album/82f65429d341cd729bc2cf6dd53ed11acee4c661.png)

- eg：

![image-20220415214740301](https://i0.hdslb.com/bfs/album/c9f6283a9cf45def89b98a832f75a9d7191f6b16.png)



**短作业优先（SJ(P)F）**

- 该算法是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度

![image-20220416114143421](https://i0.hdslb.com/bfs/album/e9ecdadc3c931b5021665b782689689b730093a1.png)

- eg：

![image-20220416112031890](https://i0.hdslb.com/bfs/album/8520deca7242deb508fdbfc15db5743753e5c806.png)



**高响应比优先（HRRN）**

![image-20220416115510681](https://i0.hdslb.com/bfs/album/4a1a14e84327f6570919fbe55562b42936b8aaf5.png)

- eg：

![image-20220416115257776](https://i0.hdslb.com/bfs/album/1a906b9c7e53097ed1154618a02c3932cdaa6b7f.png)



**三种算法对比**

![image-20220416120053194](https://i0.hdslb.com/bfs/album/06038c575986cec22fab9749815f858c23f61519.png)

三种算法适用于 **早期批处理系统**



### 3.3 进程调度

**不能进行**进程调度与切换的情况：

- **处理中断的过程中**
- 进程在 **操作系统内核程序临界区中**
- 在 **原子操作过程中**

**进程调度的任务**

- 保存处理机的现场信息
- 按某种算法选取进程
- 把处理器分配给进程

**进程调度的机制**

​	为实现进程调度，在进程调度机制中，应具有如下三个基本部分，如下图所示

- 排队器
- 分排器
- 上下文切换器

![image-20220416124238270](https://i0.hdslb.com/bfs/album/feba90d1543fb3bb79f164962b054c1652a12db5.png)

**进程调度的方式**

- **非抢占式（非剥夺调度方式）：**只允许进程主动放弃处理机。**实现简单**，适用于早期的 **批处理系统**
- **抢占方式（剥夺调度方式）：**这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。**可以优先处理更紧急的进程**，适用于 **分时操作系统，实时操作系统**



**时间片轮转算法（RR）**

![image-20220416171933364](https://i0.hdslb.com/bfs/album/8cce87b194fda551666f1d9d3ccc8345ec99e906.png)

- **时间片的选择**
  - 时间片太大算法会退化为 **先来先服务算法**
  - 时间片太小进程切换过于频繁

- eg：

![image-20220416170707338](https://i0.hdslb.com/bfs/album/a3cf1fe79ade35cd888682eec35199b17fe6ef78.png)

![image-20220416170534459](https://i0.hdslb.com/bfs/album/89d7db871ecc86cf7dfff01dc4dbc3d4d8e2aa9d.png)

![image-20220416170737553](https://i0.hdslb.com/bfs/album/8cdf1d4d01d7ad9d39010307b094916cb6bf4843.png)



**优先级调度算法**

![image-20220416173114719](https://i0.hdslb.com/bfs/album/52e7256936658c6f89c2fdd071255f494c5387ca.png)

eg：

- 非抢占式

![image-20220416172216106](https://i0.hdslb.com/bfs/album/2526d15bd29cf64e5e2a65cf665cf174607a9795.png)

- 抢占式

![image-20220416172405862](https://i0.hdslb.com/bfs/album/a43808f229bcda9e9e9b26ed89010fad30b9de4e.png)



**多级反馈队列调度算法**

![image-20220416173820473](https://i0.hdslb.com/bfs/album/c6db4351c9b17324de2d55dc4f1a31b72d529a96.png)

- eg：

![image-20220416173611680](https://i0.hdslb.com/bfs/album/93ece3d750c70fc4cd4da450e488101887de5e0e.png)



**三种算法对比**

![image-20220416173843563](https://i0.hdslb.com/bfs/album/204334e68907b3a9b85405288e85f5425f8d2693.png)

- 这三种算法适用于 **交互式系统**



### 3.4 实时调度

在实时系统中，可能存在着两类不同性质的实时任务，即**HRT（Hard Real-time，硬实时）任务**和**SRT（Soft Real-time，软实时）任务**。实时调度必须能满足实时任务对截止时间的要求

**实现实时调度的基本条件**

- 提供必要的信息
  - 就绪时间
  - 开始截止时间和完成截止时间
  - 处理时间
  - 资源要求
  - 优先级
- 系统处理能力强
- 采用抢占式调度机制
- 具有快速切换机制

**实时调度算法的分类**

- 非抢占式调度算法
  - 非抢占式轮转调度算法
  - 非抢占式优先调度算法
- 抢占式调度算法
  - 基于时钟中断的抢占式优先权调度算法
  - 立即抢占(Immediate Preemption)的优先权调度算法
  - 

**常用的几种实时调度算法**

- 最早截止时间优先即EDF(Earliest Deadline First)算法 
- 最低松弛度优先即LLF(Least Laxity First)算法 



### 3.5 死锁的概念

![image-20220417171513832](https://i0.hdslb.com/bfs/album/36b566e1b3309200f728856a7c453bb672e17f87.png)

**死锁、饥饿、死循环的异同**

![image-20220417170121974](https://i0.hdslb.com/bfs/album/291f6591575a860074871dae45f3be7b81c4f209.png)



### 3.6 死锁的处理策略-预防死锁

![image-20220417171626531](https://i0.hdslb.com/bfs/album/252ce2d65489b4a2f2d6387cd42de26ef0e49c50.png)

### 3.7 死锁的处理避免死锁

**安全状态**

安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …, Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态

**银行家算法**

- **数据结构**
  - 可利用资源向量 **Available**
  - 最大需求矩阵 **Max**
  - 分配矩阵 **Allocation**
  - 需求矩阵 **Need**

- 详情

  - 当进程$p_i$发出资源请求后，进行检查：
    - 若Request<=Reed[i]，进行第二步
    - Request<=Acailable

  - 系统进行资源预分配

    - Available = Avaiable - Request
    - Allocation[i] = Allocation[i] + Request
    - Need[i] = Need[i] - Request

  - 执行安全性算法

    是否可以找到一个安全序列

### 3.8 死锁的检测与解除

**数据结构：资源分配图**

- 使用**圆形**表示进程
- 使用**矩形**表示资源
- **矩形中的小圆**表示资源的数量
- eg：![image-20220424212203442](https://i0.hdslb.com/bfs/album/71bfd840aaaf158f4fd9c4b26d96cd455f18e143.png)

![image-20220424211532454](https://i0.hdslb.com/bfs/album/f73c9a6612935fc0b7bcc981fe7799a822ea8813.png)



## 第四章 存储器管理

### 4.1 存储器的层次结构

**存储器的多次结构**

![image-20220424213751455](https://i0.hdslb.com/bfs/album/c4b74bae3e6022e214fb212f794380ec5b3d88b6.png)

- **寄存器：**与CPU协调工作，**用于加速存储器的访问速度**，如用寄存器存放操作数，或用作**地址寄存器加快地址转换速度**等
- **高速缓存：**根据程序执行的**局部性原理**将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度
- **主存储器：内存，保存进程运行时的程序和数据**。CPU与外围设备交换的信息一般也依托于主存储器地址空间。**为缓和主存储器的访问速度远低于CPU执行指令的速度，在计算机系统中引入了寄存器和高速缓存**。
- **磁盘缓存：**将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可**减少访问磁盘的次数**。它依托于固定磁盘，提供对主存储器存储空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读/写入的信息

### 4.2 程序的装入和链接

![image-20220424214854064](https://i0.hdslb.com/bfs/album/1193a6c23ce2cc64f32591e223a27798dc9b80ee.png)

![image-20220424215639505](https://i0.hdslb.com/bfs/album/d753be27bbdb7700264ef337997ddc63402b6806.png)

**装入时动态链接方式有以下优点**：

- **便于修改和更新**
- **便于实现对目标模块的共享**



### 4.3 内存管理的概念

![image-20220424222108045](https://i0.hdslb.com/bfs/album/99942d65032dc58797b34fd6418fa8ae6f9a5387.png)



### 4.4 覆盖与交换

为了实现 **内存空间扩充**

**覆盖技术：**

- 将内存分为 **固定区** 和 **覆盖区**
- 常驻内存的程序段放入 **固定区，放入后不再调出**
- 不常用的段放在 **覆盖区，需要使再调入内存，用不到时调出内存**
- **对用户不透明**，增加了编程难度

eg：![image-20220424222729524](https://i0.hdslb.com/bfs/album/5bc2e637ef1aba0ff40bd227b79fc6ebdd471ab1.png)

![image-20220424225806110](https://i0.hdslb.com/bfs/album/65e0ae499f2053e5631c7b8db47509b2fdc6673d.png)

 

### 4.5 连续分配管理方式

**连续分配：**用户进程分配的必须是一个 **连续的内存空间**

**单一连续分配：**

- 内存被分为 **系统区** 和 **用户区**
- 内存中 **只能有一道用户进程**

<img src="https://i0.hdslb.com/bfs/album/60d62e5cdcbdb76b6be2c903a54a3a55da3c4d26.png" alt="image-20220425214828296" style="zoom:50%;" />

**固定分区分配：**

- 建立 **分区说明表**
- <img src="https://i0.hdslb.com/bfs/album/9127ebbd40f124af01b5ef3c6c5b28c007025beb.png" alt="image-20220425215042060" style="zoom: 50%;" />

<img src="https://i0.hdslb.com/bfs/album/3e46b8a21a3d5496576461fd8ca4db81db48c90a.png" alt="image-20220425214807180" style="zoom: 50%;" />

**动态分区分配**

- 数据结构

  - 空闲分区表

    ![image-20220425220349962](https://i0.hdslb.com/bfs/album/9a9378488507ed26f139e8482011ede33980f26f.png)

  - 空闲分区链

    ![image-20220425220402705](https://i0.hdslb.com/bfs/album/8da5e668ce2b4ce1fbd849d0c0e8363cceed06e8.png)

![image-20220425214142865](https://i0.hdslb.com/bfs/album/1f4b1079b8e45bcf151f8c71eb74a6255e681a7a.png)

### 4.6 动态分区分配算法

![image-20220425222417102](https://i0.hdslb.com/bfs/album/1d8708d38fca94d1d108d7bc4b57b36fb15493d9.png)

### 4.7 可重定位分区分配

**紧凑**

- 为了消除外零头，进一步提高主存的利用率，定时地（或者在主存空间紧张时）把主存中的作业“搬家”集中在主存的一端。另一端就产生了一个大的空闲区。这种技术称为存储器的 **紧凑**
- **优点： 解决了可变分区分配所引入的“外零头”问题，解决了可变分区分配所引入的“外零头”问题**
- **缺点：提高硬件成本，紧凑时花费CPU时间**

![image-20220430111356833](https://i0.hdslb.com/bfs/album/a5c40e1fd16644bda38d70cfa15575c939592b83.png)

**动态重定位**

- 系统中增加一个**重定位寄存器**，用它来装入程序在内存中的**起始地址**，程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成。地址变换过程是在程序执行期间，随着对每条指令和数据的访问而自动进行的，故称为**动态重定位**

![image-20220430111900346](https://i0.hdslb.com/bfs/album/c63ab4a8ba3a15b227fc5644d0c5a28f5b27e9b2.png)

**动态重定位分区分配算法**

内存不足时，**紧凑**

![image-20220430112005572](https://i0.hdslb.com/bfs/album/6d2718c825cec147732a9625ff82f2d512165ff1.png)

### 4.8 基本分页存储管理

分页存储的基本思想：**离散分配**，将程序分为相同大小的块，分别存储

**页框/页帧/内存块/物理块**：内存空间分为的一个个 **大小相等的分区**（**页框不能太大，可能会产生内部碎片，一般为2的幂**）

**页框号/内存块号/页帧号/物理块号：** **页框/页帧/内存块/物理块**的编号，**从0开始**

**页/页面：**将用户进程的地址空间也分为 **与页框大小相等** 的一个个区域

**页号：**页面的编号从0开始

<img src="https://i0.hdslb.com/bfs/album/b3c47e399fe5b93b24db788d1a52136a8d967db0.png" alt="image-20220430113308935" style="zoom: 50%;" />

**如何实现地址转换**

- **物理地址=页面实址+页内偏移量**

- 分页地址中的地址结构如下：

  ![image-20220430114003041](https://i0.hdslb.com/bfs/album/dc726a54d4786fe88f981c51fdc057d1b47b637a.png)

- **若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得：**

  <img src="https://i0.hdslb.com/bfs/album/c027594f40722aebcff9c62c365769eea3a0f890.png" alt="image-20220430114048278" style="zoom:50%;" />

**页表**

​	**操作系统为每个进程建立一张页表**

![image-20220430114612239](https://i0.hdslb.com/bfs/album/75abf1c0061b239add2b4ab29b6fa3722936cfb1.png)



![image-20220430112753137](https://i0.hdslb.com/bfs/album/e569da5a72c9e2e5df43149b2aac9016a4452c0d.png)



### 4.9 基本地址变换机构

- 在系统中设置一个**页表寄存器PTR**，其中存放页表在内存的始址和页表的长度
- 平时，进程未执行时，页表的始址和长度是存放在本进程的**PCB**中，当调度程序调度到某进程时，才将它们装入到页面寄存器中

![image-20220430121243558](https://i0.hdslb.com/bfs/album/b3cc8646269f7470408ea5bbf8b824fe63e1eb81.png)

![image-20220430121438427](https://i0.hdslb.com/bfs/album/07e0b0bcc04b3683d17454a452011c79ca164fb6.png)

 ![image-20220430121701317](https://i0.hdslb.com/bfs/album/50edc5d7a1db59979d7a129349b69c97dceaf433.png)

### 4.10 具有块表的地址变换机构

为了提高地址变换速度，可在地址变换机构中，增设一个具有并行查寻能力的**特殊高速缓冲存储器，又称为“联想存储器”或“快表”（TLB**），用以存放当前访问的那些页表项

![image-20220430122927567](https://i0.hdslb.com/bfs/album/1f225910cbb94220e4516753bdbba18293ee9b40.png)

**对比**

![image-20220430122954057](https://i0.hdslb.com/bfs/album/6a57a3a6c1fb66fdfe9212a84cb5b3dc5cc9622b.png)

### 4.11两级页表

**单级页表存在的问题**

- **页表必须连续存放**

- **页表常驻内存**

**逻辑地址的结构**

<img src="https://i0.hdslb.com/bfs/album/c1bd647c6b607d89252a05f7c13158972c4c412f.png" alt="image-20220430124052796" style="zoom:50%;" />

**两级页表解构**

![image-20220430124238922](https://i0.hdslb.com/bfs/album/3c73a0a52b01c0bbfb0ba234b65ccf92a1cf7d7b.png)

![image-20220430124336482](https://i0.hdslb.com/bfs/album/770baf01bfef631acd1df8cf691d1cab1fa0855d.png)

### 4.12 基本分段存储管理方式

采用 **分页存储管理方式时**，常常会将逻辑相关的部分划分到不同的页面，造成共享、保护困难，于是产生了 **分段** 的思想

**解决问题/优点：**

- **方便编程**
- **分段共享**
- **信息保护**
- **动态链接**
- **动态增长**

**分段**

- **地址结构**

  ![image-20220430125021518](https://i0.hdslb.com/bfs/album/5d1fd1c30b9bcd0d238a5ce457cb0a4529845101.png)

- **段表**

  ![image-20220430125049258](https://i0.hdslb.com/bfs/album/93da807d5ed435a3390bb993b6f1ba6968ed2eeb.png)

**地址变换机构**

![image-20220430125208069](https://i0.hdslb.com/bfs/album/38721117e706f9db3567c943ef7fd749a4d1bf1f.png)



![image-20220430124801168](https://i0.hdslb.com/bfs/album/9444e1f0df111a313ba813abec7b41cc6e0cfef2.png)

### 4.13 段页式存储管理方式

**分段与分页方式的优缺点**

![image-20220430125525806](https://i0.hdslb.com/bfs/album/74c0095ad84ab97d4d57fed89ef3acd6f695f3c1.png)

**基本思想**：

- 将每个进程按逻辑模块分段，再将各段分页

**段页式存储逻辑地址结构**

![image-20220430125944029](https://i0.hdslb.com/bfs/album/c9f76ac14d3722f4aca5ca988ecde4b858483b3f.png)

**地址变换过程**

![image-20220430130126606](https://i0.hdslb.com/bfs/album/45014131adc54c52694682b1110096074d20e71b.png)

**总结**

![image-20220430130156808](https://i0.hdslb.com/bfs/album/6e61dd76837362cb4eacaa8bd44536347c260bbf.png)

## 第五章 虚拟存储器

### 5.1 虚拟存储器概述

实现**内存扩充**的方式，比覆盖和交换更加高级 

![image-20220501212241199](https://i0.hdslb.com/bfs/album/04cadf2e3aec24a949024d52dc9803e6e010fc8c.png)

### 5.2 请求分页存储管理方式

 请求分页管理方式需要解决的问题：

- **系统如何获知进程当前所需页面不在主存**
- 当发现缺页时**，**如何把**所缺页面调入主存**
- 当主存中没有空闲的页框时，为了要接受一个新页，需要把老的一页淘汰出去，**根据什么策略选择欲淘汰的页面**

**页表机制**

![image-20220503114708966](https://i0.hdslb.com/bfs/album/53bb283727636895bfb71adea0f6d577e73aa3e5.png)

- **状态位P**：用于指示该页是否已调入内存，供程序访问时参考
- **访问字段A**：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。
- **修改位M**：表示该页在调入内存后是否被修改过。作为该页换出时是否写回外存的依据。
- **外存地址**：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用

**中断的分类**

![image-20220503115929540](https://i0.hdslb.com/bfs/album/ea451d2a141d050ca72cb3bf2be12c662033bffd.png)

**地址变换机构**

![image-20220503120616264](https://i0.hdslb.com/bfs/album/9c75eb296d0bd617525652f5e6722a6299bbf5c2.png)

![image-20220503121752467](https://i0.hdslb.com/bfs/album/e8014b8d73471420e47c082bd85451bd1f5a9302.png)

### 5.3 页面置换算法

用页面置换算法决定应该换出那个页面

**最佳置换算法（OPT）**

- 被淘汰页面，将是以后永不使用的， 或许是在最长(未来)时间内不再被访问的页面

- eg：

![image-20220503123019245](https://i0.hdslb.com/bfs/album/39a100d7dba49a7b7027b07dafe88c363f0959b7.png)

**先进先出置换算法（FIFO）**

- 每次选中淘汰的页面是最早进入内存的页面
- 会产生 **Belady异常**：为进程分配的物理块数增大时，缺页次数不增反减
- eg：![image-20220503123808620](https://i0.hdslb.com/bfs/album/66cc4eace316c5b827ec15261a9c4f50012530ec.png)

**最近最久未使用置换算法（LRU）**

- 每次淘汰页面是最近最久未使用的页面
- eg：![image-20220503124222379](https://i0.hdslb.com/bfs/album/4ce597371d2657078a0caac87fc014c6b832c22d.png)

**时钟置换算法/最近未用算法（CLOCK/NRU）**

- **页表项**：![image-20220503125738209](https://i0.hdslb.com/bfs/album/b80913d14a3e857e02b5a37e0bdd2d1028384d83.png)

- **实现方法**：![image-20220503125953462](https://i0.hdslb.com/bfs/album/fb268961e78a29aed499dda5f341b64b61100dc1.png)

  

**改进型的时钟置换算法**

- 使用**（访问位，修改位）**的形式表示各页状态，eg：（1，1）表示一个页面近期被访问过，且被修改过

- **算法规则：**![image-20220503130341005](https://i0.hdslb.com/bfs/album/1ea25b63150754808de5d378d2b79eddb195713e.png)

- **淘汰优先级**
  1. 最近没访问，且没修改
  2. 最近没访问，但修改过
  3. 最近访问过，但没修改
  4. 最艰难访问过，且修改过

**总结**

![image-20220503132104842](https://i0.hdslb.com/bfs/album/081c4540c72d124990189c83c2425f22931de769.png)



### 5.4 页面分配策略

驻留集：能保证进程正常运行所需的**最小物理块数**

**总结**

<img src="https://i0.hdslb.com/bfs/album/c571bb915e834b8db3e295be059898c8a6551bd0.png" alt="image-20220503132330589" style="zoom:150%;" />

### 5.5  请求分段存储管理方式

**段表机制**

![image-20220503135452839](https://i0.hdslb.com/bfs/album/7baf797699be84cee70b4d3a7ec6e14b89142e19.png)
